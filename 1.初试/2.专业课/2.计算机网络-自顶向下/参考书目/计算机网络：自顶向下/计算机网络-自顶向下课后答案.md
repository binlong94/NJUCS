# 计算机网络：自顶向下方法，第7版

## 复习题和习题参考答案


### 版本时间：2016年12月

本文档包含Jim Kurose和Keith Ross编写的《计算机网络：自顶向下方法（第7版）》复习题和习题的参考答案。这些答案只对指导老师有效。请不要复制或者分发给其他人（即使是其他指导老师）。请不要在公共网络发布任何参考答案。如果有需要，我们很乐意提供此参考答案（最新版）。

声明：这些年来，很多同学和同事帮助我们准备此参考答案。特别感谢Honggang Zhang，Rakesh Kumar，Prithula Dhungel和VijayAnnapureddy。同时也感谢提建议和修正错误的所有读者。

所有材料©1996-2016 由J.F.Kurose 和K.W.Rose提供。版权所有。


# 说明

译者：李加其

时间：2019-10-6

版本：2019.10.06

电话：13812991101

QQ：1768478912

邮箱：1768478912@qq.com

环境：Manjaro Linux 18.1.0+WPS11.1.0.8865+自带公式编辑器+vscode insider version Markdown

1、此参考答案所有内容版权由原作者所有，本人为了方便考研复习提供简体中文版本的翻译。

2、阁下在获取到此文档的同时，应该同时获取到此文档的英文原版PDF。此文档的中文版权归本人所有，提供给需要的人使用。

3、阁下在使用本文档时，不得添加水印、删减或修改内容。

4、当然，以上内容只是说说而已，你如果不遵守，我也不可能顺着网线去打你。

5、如果有侵权（对于原作者）或者其他的问题或者建议，欢迎联系我。

6、阁下在使用本文档时，请保留此页面和原版翻译的封面。

7、根据南京大学计算机845真题的内容，本文档只翻译第1-7章。

# 目录

[第一章](#第一章)
- [复习题](#复习题1)
- [问题](#问题1)

[第二章](#第二章)
- [复习题](#复习题2)
- [问题](#问题2)

[第三章](#第三章)
- [复习题](#复习题3)
- [问题](#问题3)

[第四章](#第四章)
- [复习题](#复习题4)
- [问题](#问题4)

[第五章](#第五章)
- [复习题](#复习题5)
- [问题](#问题5)

[第六章](#第六章)
- [复习题](#复习题6)
- [问题](#问题6)

[第七章](#第七章)
- [复习题](#复习题7)
- [问题](#问题7)

[参考文档](#参考文档)


# 第一章

## 复习题1

1、（1）没有区别。根据书本内容，“主机”和“终端系统”是交换使用的。

（2）终端系统包括PC、工作站、网络服务器、邮件服务器、PDA、连接网络的游戏控制台等等。

（3）由（2）可知，网络服务器是终端系统。

2、来自维基百科：外交协议常用于描述一系列国家来往规则。这些构建完备和经过时间检验的规则可以使国家和人民生活和工作更简单。协议规则以人民准则为基础，其中的一部分已经作为现在分级的地位声明。

3、标准对于协议来说，可以让人们创建可以相互操作的网络系统和产品。

4、（1）通过电话线的拨号调制解调器：家庭

（2）通过电话线的DSL（Digital Subscriber Line，数字用户线）：家庭或小办公室

（3）混合光纤同轴电缆：家庭

（4）100M交换以太网：企业

（5）无线网：家庭或企业

（6）3G和4G：广域无线网

5、HFC带宽是由用户共享。下行通道中，所有的包都是由头端这一个单一源发出的。因此，下行通道中没有碰撞。

6、光纤到户、3G和4G无线网

7、10M、100M、1G、10G

8、双绞线、光纤

9、拨号调制解调器：最高56K，带宽专用
   ADSL：下行最高24M，上行最高2.5M，带宽专用
   HFC：下行最高42.8M，上行最高30.7M，带宽共享
   FTTH：上行2-10M，下行10-20M，带宽不共享

10、现在最流行的无线网技术有两种：

（1）WiFi。用于无线局域网，无线用户从辐射范围为几十米的基站（例如无线接入点）传输数据包。基站连接无线网络，并为无线用户提供无线网服务。

（2）3G和4G。大范围无线网，此系统通过电信服务商提供的基站，由蜂窝电话通过同一个无线设备传输数据。可以提供基站几十千米范围内的无线网络。

11、$t_0$时发送主机开始传输，$t_1=L/R_1$时发送端完成传输并且交换机收到完整的数据包（没有传播延时）。因为交换机在$t_1$时已收到完整包，那么$t_1$时交换机开始传输包至接收主机。$t_2=t_1+L/R_2$时交换机完成输出并且接收主机收到完整包（没有传播延时）。因此，端到端总延时是$L/R_1+L/R_2$。

12、电路交换网络可以在响应时间内保证一定量的端到端带宽。如今大部分分组交换网络（包括因特网）无法保证端到端带宽。FDM需要复杂的模拟硬件来将信号转换为合适的频率。

13、（1）2个用户，每个用户只需要一半的链接带宽；

   （2）既然每个用户传输时要求1Mpbs带宽，如果两个或者更少的用户同时传输，要求最多2Mbps。共享链路的可用带宽是2Mbps，那么传输前没有排队延时。如果有3个用户同时传输，带宽要求是3Mbps，超过了共享链接可用带宽。这种情况下，连接之前会有排队延时。

   （3） 一个用户传输的概率是0.2

   （4）3个用户同时传输的概率是 $\binom{3}{3} p^{3} (1-p)^{3-3}$ 。因为用户传输是队列会增加，队列增加时的时间因素是0.008。

14、如果两个ISP不对等，那么当他们给对方发送流量时他们需要通过一个付费流量ISP提供商（中间商）来发送数据。通过直接对等传输，两个ISP可以减少给其他ISP提供商的费用。多个ISP可以通过网络交换点（IXP）（通常由它自己的交换机单独构建）作为汇合点来直接对等传输。ISP通过对连接至IXP的每一个ISP收取少量费用来盈利，当然利润取决于IXP发送或接收的流量数。

15、谷歌的私有网络连接了它大大小小的所有的数据中心。谷歌数据中心的流量通过它的私有网络而不是公共网络来传输。大多数的数据中心位于或靠近与低级的ISP。因此，当谷歌向用户分发数据时，可以跳过高级的ISP。是什么推动着这些内容提供商创建这些网络？首先，如果内容提供商使用更少的中间的ISP，它可以更容易控制用户体验。其次，通过减少至提供商的网络流量来节省成本。第三，如果ISP向利润率高的内容提供商收取高费用（在网络中立状态不适用的国家或地区），内容提供商可以避免额外成本。

16、延迟组件包括处理延迟、传输延迟、传播延迟、排队延迟。除了排队延迟是变量其他的都是固定的。

17、a）1000km, 1Mpbs, 100bytes
   b）100km, 1Mpbs, 100bytes

18、（1）10msec
   （2）d/s
   （3）无关
   （4）无关

19、(1) 500kps
   (2) 64 seconds
   (3) 100kps；

20、终端系统A将大文件拆分为块。A通过添加文件头信息至每一个块来从文件生成多个数据包。数据包的头信息包含目标（终端系统B）IP地址。数据包交换机通过包中的目标IP地址来决定发送链接。考虑到包目标地址，包选择哪条路走和包选择哪条外链走的方法相似。

21、最大发送速率为500包/s，最大传输速率是350包/s。相对应的话务量强度是500/350=1.43>1。每次实验最终都会发生数据丢失；由于传输的随机性，每一次实验的数据丢失发生的时间都是不同的。

22、五个功能是：错误控制、流控制、片段化和重组、多任务和连接设置。没错，在不同层这些功能可能重复。例如，不止一层提供错误功能。

23、网络协议的自顶向下的五层是：应用层、传输层、网络层、链路层和物理层。详见1.5.1。

24、应用层报文：应用程序想发送和通过传输层的数据；

   传输层段：由传输层生成并且封装有传输层头信息的应用层报文

   网络层数据段：封装有网络层头信息的传输层段

   链路层帧：封装有链路层头信息的网络层数据段

25、路由器处理网络、链路、物理层（第1到3层）。（实际上现代路由器有时担任防火墙、缓存组件和处理传输层）链路层交换机处理链路层和网络层（第1到2层）。主机处理所有的五层。

26、a）病毒

   需要以下人的交互来传播。比如邮件病毒。

   b）蠕虫

   不需要用户介入。受感染主机中的蠕虫会扫描IP地址和端口号来查找可感染的进程。

27、创建僵尸网络需要攻击者发现以下应用或系统的薄弱点（比如利用应用中可能存在的缓冲区溢出漏洞）。发现薄弱点后，黑客需要查找可攻击的主机。目标一般是已发现漏洞的一系列系统。僵尸网络中的任何系统都可以通过漏洞自动扫描它的环境和传播。这种僵尸网络的重要属性就是僵尸网络的起点可以远程控制和发送命令至僵尸网络中的所有结点的每一个节点（例如僵尸网络中的所有结点可以被黑客命令发送TCP SYN信息至目标，并将导致目标的TCP SYN溢出攻击）。

28、Trudy可以假装为Bob（反之亦然）并且部分或者完全修改Bob发送给Alice的信息。例如，她可以很容易的修改语句“Alice，我欠你1000美元”为“Alice，我欠你10000美元”。更进一步，Trudy甚至可以丢弃Bob发送给Alice的加密信息（反之亦然）。

[Back to Index](#目录)

## 问题1

P1. 这个问题不止一个答案。很多协议都可以解决这个问题。下面是一个简单的答案：

| Msg name | purpose |
|--------- |-------- |
|HELO <userid> | Let server know that there is a card in the ATM machine . ATM card transmits user ID to Server |
|PASSWD <passwd> | User enters PIN, which is sent to server . BALANCE User requests balance |
|WITHDRAWL <amount> | User asks to withdraw money . BYE user all done |

从服务器至ATM机器的信息（显示）

| Msg name | purpose |
|--------- |-------- |
|PASSWD | Ask user for PIN (password) |
|OK | last requested operation (PASSWD, WITHDRAWL) OK |
|ERR | last requested operation (PASSWD, WITHDRAWL) in ERROR |
|AMOUNT <amt> | sent in response to BALANCE request |
|BYE | user done, display welcome screen at ATM |

正确回应：

|client | server |
|-------|--------|
|HELO (userid) | --------------> (check if valid userid) |
| | <------------- PASSWD |
|PASSWD <passwd> | --------------> (check password) |
| | <------------- OK (password is OK) |
|BALANCE |--------------> 
| | <------------- AMOUNT <amt> |
|WITHDRAWL <amt> | --------------> check if enough $ to cover withdrawl |
| | <------------- OK |
|ATM dispenses $ 
|BYE | --------------> |
| | <------------- BYE |

钱不够的情况下：

|client | server |
|-------|--------|
|HELO (userid) |--------------> (check if valid userid) |
| |<------------- PASSWD |
|PASSWD <passwd> |--------------> (check password) |
|| <------------- OK (password is OK) |
|BALANCE |--------------> |
|| <------------- AMOUNT <amt> |
|WITHDRAWL <amt> |--------------> check if enough $ to cover |
withdrawl ||
| |<------------- ERR (not enough funds) |
|error msg displayed ||
|no $ given out ||
|BYE |--------------> |
| | <------------- BYE|

P2. N*(L/R)时，第一个包到达目的地，第二个包存储在最后一个路由器中，第三个包存储在倒数第二个路由器中，等等。N*(L/R)+L/R时，第二个包到达目的地，第三个包存储在最后一个路由器中，等等。按照这个逻辑继续，我们可以看到在N*(L/R)+(P-1)*(L/R)=(N+P-1)*(L/R)时所有数据包到达目的地。

P3.

a.电路交换网，因为应用将以稳定速率，持续长时间运行，因此可以为其保留带宽。

b.不需要，传输速率总和小于链路容量。

P4.

a.
比如：
A 到 B ：4 条
B 到 C ：4 条
C 到 D ：4 条
D 到 A ：4 条
这 16 条可以同时连接。

b.
A 到 B ：4 条
B 到 C ：4 条
最多 8 条。

c.
可以。
A 到 B ：2 条
B 到 A ：2 条
A 到 D ：2 条
B 到 C ：2 条

P5.

a.
收费站将整个车队推向公路的时间为 d1 = 2min；
两收费站之间距离 75 km，从一个收费站到另一个的时间 d2 = 0.75 h
总时间 d = 3d1 + 2d2 = 96min

b.
d1’ = 8辆 / 5辆/min = 1.6min
d’ = 3d1’ + 2d2 = 94.8min

P6.

a.
dprop=m/s

dprop=m/s

b.
dtrans=L/R

dtrans=L/R

c.
de2e=dprop+dtrans=m/s+L/R

de2e=dprop+dtrans=m/s+L/R

d.
刚刚离开 A

e.
在链路上

f.
已经到达 B

g.
dprop = dtrans
m/s = L/R
m = Ls/R = 120b * (2.5 *10^8)m/s / 56kbps = (5.36 * 10^5)m
P7.

主机 A 产生 56 字节的分组需要 = 56 * 8b / 64kbps = 7ms
传输时延 = 56 * 8b / 2Mbps = 0.224ms
总时间 = 7ms + 10ms + 0.224ms = 17.224ms
P8.

a.
3Mbps/150kbps = 20

b.
p = 0.1

c.
(120n)pn(1−p)120−n

(n120​)pn(1−p)120−n

d.
1−∑20n=0(120n)pn(1−p)120−n

1−∑n=020​(n120​)pn(1−p)120−n

根据中心极限定理：
令 Xj
Xj​ 为独立随机变量 P(Xj=1)=pP(Xj​=1)=p ；
P(21或更多用户)=1−P(∑120i=1Xi≤21)P(21或更多用户)=1−P(∑i=1120​Xi​≤21)
P(∑120i=1Xi≤21)=P(∑120i=1Xi≤12120∗0.1∗0.9√≤9120∗0.1∗0.9√)≈P(Z≤93.286)=P(Z≤2.74)=0.997P(∑i=1120​Xi​≤21)=P(120∗0.1∗0.9
​∑i=1120​Xi​≤12​≤120∗0.1∗0.9
​9​)≈P(Z≤3.2869​)=P(Z≤2.74)=0.997
因此 P(21或更多用户)≈0.003

P(21或更多用户)≈0.003
P9.

a.
N=1Gbps100kbps=104

N=100kbps1Gbps​=104

b.
∑Mn=N+1(Mn)pn(1−p)M−n

∑n=N+1M​(nM​)pn(1−p)M−n
P10.

Dtrans=L/R1+L/R2+L/R3
Dtrans=L/R1+L/R2+L/R3
Dprop=d1/s1+d2/s2+d3/s3Dprop=d1/s1+d2/s2+d3/s3
Dprop=2∗dprocDprop=2∗dproc
D=Dtrans+Dprop+DprocD=Dtrans+Dprop+Dproc
D=6+6+6+20+16+4+3+3=64ms

D=6+6+6+20+16+4+3+3=64ms
P11.

D=Dprop+L/R=20+16+4+6=46ms

D=Dprop+L/R=20+16+4+6=46ms
P12.

有一个完整分组的排队时延为 1500∗8b2Mbps=0.6ms
2Mbps1500∗8b​=0.6ms
4.5个分组的总排队时延为 4.5∗0.6ms=2.7ms

4.5∗0.6ms=2.7ms

一般情况：
LnR+L−xR

RLn​+RL−x​
P13.

a.
第一个分组的排队时延为 0, 第二个 L/R, 第三个 2L/R，第N个 (N-1)L/R
因此平均排队时延为 (L/R + 2L/R + … + (N-1)L/R) / N = (N-1)L/2R

b.
当下一批 N 个分组到达时，上一批已经传完，因此平均排队时延为 (N-1)L/2R
P14.

a.
IL/R(1-I) + L/R = L/R(1-I)

b.
以 L/R 为函数：
令 x = L/R： L/R(1-I) = x/(1-ax)
函数经过原点，在 x = 1/a 处趋于无穷
P15.

μ = R/L 所以 L / R(1-I) = 1 / μ-a
P16.

N = 10 + 1 = 11个分组
d = 10ms + 1/100s = 0.02s
a = N/d = 11/0.02 = 550分组/s
P17.

a
设有 N - 1 台路由器，则 de2e=∑Ni=1diproc+diprop+ditrans

de2e​=∑i=1N​dproci​+dpropi​+dtransi​

b.
de2e=∑Ni=1diproc+diprop+ditrans+diqueue

de2e​=∑i=1N​dproci​+dpropi​+dtransi​+dqueuei​
P18.

略
P19.

略
P20.

min{Rs, Rc, R/M}
P21.

仅使用一条：
max{min{R11,R12,...,R1N},min{R21,R22,...,R2N},...min{RM1,RM2,...,RMN}}

max{min{R11​,R21​,...,RN1​},min{R12​,R22​,...,RN2​},...min{R1M​,R2M​,...,RNM​}}

使用 M 条：
∑Mk=1min{Rk1,Rk2,...,RkN}

∑k=1M​min{R1k​,R2k​,...,RNk​}
P22.

不丢包概率为 1 - p， N 个路由器， 因此总的不丢包概率 (1−p)N
(1−p)N
一个分组被接收所需要的平均次数为 1(1−p)N(1−p)N1​，因此重传次数为 1(1−p)N−1

(1−p)N1​−1
P23.

a.
L/Rs

b.
可能，因为第二个分组 (用 P2 表示) 可能在第一个分组 (P1) 被推出之前到达；

P1 被完全推出的时间 t1 = L/Rs + L/Rc + dprop
P2 到达路由器的时间 t2 = 2L/Rs + dprop + T
要求 t2 > t1:
                  即 T > L/Rc - L/Rs；
因此 T 至少是 L/Rc - L/Rs
P24.

t = 40 * 10^12 * 8b / 100Mbps = 3.2 * 10^6 s = 888h = 37 天
所以使用 FedEx
P25.

a.
tprop = 20000km / 2.5*10^8m/s = 0.08s
R * tprop = 1.6 * 10^5 b

b.
1.6 * 10^5 b

c.
链路上的最大比特数量

d.
20000km / 1.6*10^5 = 125m
这比足球场长(正规足球场场地：长105米、宽68米)

e.
s/R
P26.

s/R = 20000km
R = 12.5Mbps
P27.

a.
R * dprop = 8 * 10^7 b

b.
8 * 10^7 b 是 不对 的，因为文件为 8 * 10^5 b，因此为 8 * 10^5 b

c.
s/R = 0.25m
P28.

a.
ttrans + tprop = 0.48s

b.
20 * (ttrans’ + tprop) = 20 * (0.02 + 0.08)s = 2s

c
(b)花的时间更长
P29.

a.
dprop = 36000km / (2.4 * 10^8) = 0.15s

b.
R * dprop = 10Mbps * 0.15s = 1.5 * 10^6 b

c.
60s * 10Mbps = 6 * 10^8 b
P30.

有，略
P31.

a.
8 * 10^6 / 2Mbps = 4s
3 * 4s= 12s

b.
1 * 10^4 b / 2Mbps = 5 * 10^(-3)s
5 * 10^(-3)s
5 * 10^(-3)s
2 * 5 * 10^(-3)s = 10^(-2)s

c.
(800 + 3 - 1) * 0.5 * 10^(-2) = 4.01s
比 (a) 快非常多

d.
便于检测错误并重传；不分段的大包容易使路由器缓存不足导致丢包；

e.
分组需要排序；需加上首部信息；
P32.

略
P33.

D = (3 + F/S - 1) * (80 + R) /R = (2 + F/S)(80 + S) / R
ddSD=0
dSd​D=0 因此 S=40F−−−−√S=40F

​
P34.

略


# 第二章

## 复习题2
R1.

web：http；文件传输：FTP；邮件：SMTP；P2P：Bittorrent；远程登录：telnet
R2.

网络体系结构指的是五层模型，应用程序体系结构指的是 P2P 或者 客户-服务器
R3.

先发起对话的是客户，接收请求的是服务器
R4.

不同意，发送文件的对等方通常被称为服务器，接收文件的被称为客户
R5.

端口和 IP
R6.

UDP
R7.

QQ
R8.

    可靠数据传输：TCP 提供
    吞吐量：都不提供
    定时：都不提供
    安全性：都不提供

R9.

SSL 运行在应用层；
如果想要强化TCP，需要把 SSL 的代码写到程序里；
中文版的课本上写的是 UDP，UDP 不能用 SSL；
R10.

握手协议是指主要用来让客户端及服务器确认彼此的身份的一类网络协议
R11.

因为这些应用都需要可靠传输服务，而 UDP 不能提供
R12.

当用户初次访问网站时，服务器创建一个独一无二的标志数，在返回客户端的报文中发送给用户，这个数被称为 cookie，由浏览器维护；当用户请求查看购物车时，cookie 插在报文中被发送到服务器，服务器返回特定 cookie 对应的购物车信息
R13.

Web 缓存器中保存最近请求过的对象的副本。会减少所有对象的时延。
R14.

USER@NAME:~# telnet httpd.apache.org 80
Trying 40.79.78.1...
Connected to httpd.apache.org.
Escape character is '^]'.
GET /index.html HTTP/1.1
Host: httpd.apache.org
If-Modified-Since: Sat, 22 Sep 2018 11:41:57 GMT

HTTP/1.1 304 Not Modified
Date: Tue, 02 Oct 2018 07:19:28 GMT
Server: Apache/2.4.18 (Ubuntu)
ETag: "24ea-576743e4db26f"

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

R15.

FTP 有一条控制连接，一条数据连接
R16.

首先报文通过 HTTP 传送到 Alice 的邮件服务器，然后服务器通过 SMTP 将报文发送到 Bob 的服务器，然后 Bob 用 POP3 接收这个报文
R17.

手动打码 (ಡωಡ)

USER@NAME:~# telnet pop.163.com 110
Trying 123.125.50.29...
Connected to pop3.163.idns.yeah.net.
Escape character is '^]'.
+OK Welcome to coremail Mail Pop3 Server (163coms[b62aaa251425b4be4eaec4ab4744cf47s])
user ****@163.com
+OK core mail
pass ****
+OK 3 message(s) [9082 byte(s)]
list
+OK 3 9082
1 3406
2 2376
3 3300
.
TOP 1 0
+OK 3406 octets
Received: ****
Date: ****
From: ****
To:****@163.com
...

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22

各头部信息可以参考 RFC 5321
R18.

下载并删除模式对用户来说是不友好的，用户无法第二次查看邮件
下载并保留模式是不方便的，因为很久远的邮件也会保留下来
R19.

Web服务器可以和邮件服务器有相同的别名
包含邮件服务器的 RR 是 MX
R20.

能确定，而 gmail 却不行
R21.

不需要，Alice 必须是 Bob 的上传速率最高的 4 个邻居
R22.

在 Bittorrent 中，对等方们每过 30 秒随机选择另外的一个邻居发送块，当 Alice 被随机选中时，她将得到第一个块
R23.

覆盖网络不包含路由器，是对等方组成的逻辑网络，不是物理链路，边是两个对等方之间有 TCP 连接。
R24.

网状 DHT：
优点很明显，大大减少用于查询的时间和报文数量
缺点是每个对等方必须追踪其他所有对等方

环形 DHT：
优点是追踪的对等方少
缺点是查询时间长，报文数量多
R25.

文件下载，即时讯息，网络直播，分布式计算
R26.

TCP 有一个欢迎套接字，一个连接套接字
n + 1
R27.

TCP 需要建立连接，UDP 不需要

[Back to Index](#目录)

## 习题2

P1.

a. 错
b. 对
c. 错
d. 错
e. 错
P2.

FTP SERVICE COMMANDS:

         RETRIEVE (RETR)

         STORE (STOR)

         STORE UNIQUE (STOU)

         APPEND (with create) (APPE)

         ALLOCATE (ALLO)

         RESTART (REST)

         RENAME FROM (RNFR)

         RENAME TO (RNTO)

         ABORT (ABOR)

         DELETE (DELE)

         REMOVE DIRECTORY (RMD)

         MAKE DIRECTORY (MKD)

         PRINT WORKING DIRECTORY (PWD)

         LIST (LIST)

         NAME LIST (NLST)

         SITE PARAMETERS (SITE)

         SYSTEM (SYST)

         STATUS (STAT)

         HELP (HELP)

         NOOP (NOOP)

P3.

应用层：DNS HTTP
运输层：TCP(HTTP需要) UDP(DNS需要)
P4.

a.
gaia.cs.umass.edu/cs453/index.html

b.
1.1

c.
持续

d.
HTTP 报文中没有 IP 地址

e.
Mozilla/5.0 可以针对不同的浏览器发送不同版本的网页
P5.

a.
能
Tue, 07 Mar 2008 12:39:45 GMT

b.
Last-Modified: Sat, 10 Dec 2005 18:27:46 GMT

c.
Content-Length: 3874

d.
前五个字节："<!doc"
根据 keep-alive 看出同意持续连接
P6.

a.

   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
   maintain a persistent connection unless a Connection header including
   the connection-token "close" was sent in the request. If the server
   chooses to close the connection immediately after sending the
   response, it SHOULD send a Connection header including the
   connection-token close.

   An HTTP/1.1 client MAY expect a connection to remain open, but would
   decide to keep it open based on whether the response from a server
   contains a Connection header with the connection-token close. In case
   the client does not want to maintain a connection for more than that
   request, it SHOULD send a Connection header including the
   connection-token close.

   If either the client or the server sends the close token in the
   Connection header, that request becomes the last one for the
   connection.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

意思就是双方都可以关闭连接

b.
HTTP 并没有提供什么加密服务

c.

    Clients that use persistent connections SHOULD limit the number of
   simultaneous connections that they maintain to a given server. A
   single-user client SHOULD NOT maintain more than 2 connections with
   any server or proxy. A proxy SHOULD use up to 2*N connections to
   another server or proxy, where N is the number of simultaneously
   active users. These guidelines are intended to improve HTTP response
   times and avoid congestion.

    1
    2
    3
    4
    5
    6
    7

意思是客户最多可以和给定服务器有两条并行连接

d.

    A client, server, or proxy MAY close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

    1
    2
    3
    4
    5
    6

意思是一侧关闭连接而另一侧正在传输数据是可能的。
P7.

得到IP地址的时间 = RTT1 + RTT2 + … + RTTn
三次握手加上最后的响应 = 2 RTT0
因此总共是 2 RTT0 + RTT1 + RTT2 + … + RTTn
P8.

a.
2RTT0 + RTT1 + RTT2 + … + RTTn + 8 * 2 RTT0 = 18 RTT0 + RTT1 + RTT2 + … + RTTn

b.
2RTT0 + RTT1 + RTT2 + … + RTTn + 2 * 2 RTT0 = 6 RTT0 + RTT1 + RTT2 + … + RTTn

c.
2RTT0 + RTT1 + RTT2 + … + RTTn + RTT0 = 3 RTT0 + RTT1 + RTT2 + … + RTTn
P9.

a.
Δ = 850000b / 15Mbps = 0.0567s
β = 16请求/s
t接 = Δ/1-Δβ = 0.61s
t总 = t接 + t因 = 3.61s

b.
英文版是不命中率为0.4，这里按中文版做：
β’ = 16请求/s * 60%
t接’ = Δ/1-Δβ = 0.12s
当命中缓存器时: t命 = 850000b / 100Mbps = 0.0085s
因此 t总’ = 0.4 * 0.0085 + 0.6(t接’ + t因) = 1.8754s
P10.

10米短链路，忽略其传播时延。

带有并行连接的非持续连接且并行下载：
(200b / 150bps) * 3 + ((10^5)b/ 150bps) + (200b / (150bps / 10)) * 3 + ((10^5)b / (150bps / 10)) = 7377.3s

持续连接：
(200b / 150bps) * 3 + ((10^5)b / 150bps) + 10 * (200b/150bps + (10^5)b/150bps) = 7351s
P11.

a.
毫无疑问，是可以的，这里不做证明

b.
仍然是可以的
P12.

服务器代码：

from socket import *
import threading
def Accept(ConnectionSocket, Addr):
	Message = ConnectionSocket.recv(1024).decode('utf-8', 'ignore')
	print(Message)
	ConnectionSocket.send('haha'.encode('utf-8', 'ignore')) 
	ConnectionSocket.close()

ServerPort = 10000
ServerSocket = socket(AF_INET, SOCK_STREAM) 
ServerSocket.bind(('',ServerPort))
ServerSocket.listen()
print('listening...')
while 1:
	ConnectionSocket, Addr = ServerSocket.accept() 
	t = threading.Thread(target=Accept, args=(ConnectionSocket, Addr))
	t.start()

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

比如我先访问 http://httpd.apache.org，然后打开服务器程序，在浏览器里设置服务器程序为代理，然后再用浏览器刷新一次，出现了以下报文，说明浏览器使用了条件GET报文。如果不成功，可能要多试几次。·

GET http://httpd.apache.org/ HTTP/1.1
Host: httpd.apache.org
...
If-Modified-Since: Sat, 22 Sep 2018 11:41:57 GMT
...

    1
    2
    3
    4
    5

P13.

MAIL FROM 是 SMTP 握手协议的一部分，而 From 是邮件报文的一部分。
P14.

SMTP 使用仅包含一个句号的一行来标志报文体结束，HTTP 使用 Content-Length 标志。
不能，因为报文内容可能含有句号。
P15.

In particular, SMTP servers and clients provide a mail transport service
   and therefore act as "Mail Transfer Agents" (MTAs).  "Mail User
   Agents" (MUAs or UAs) are normally thought of as the sources and
   targets of mail.  At the source, an MUA might collect mail to be
   transmitted from a user and hand it off to an MTA; the final
   ("delivery") MTA would be thought of as handing the mail off to an
   MUA (or at least transferring responsibility to it, e.g., by
   depositing the message in a "message store").  However, while these
   terms are used with at least the appearance of great precision in
   other environments, the implied boundaries between MUAs and MTAs
   often do not accurately match common, and conforming, practices with
   Internet mail.  Hence, the reader should be cautious about inferring
   the strong relationships and responsibilities that might be implied
   if these terms were used elsewhere.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14

意思是 MTA(Mail Transfer Agents) 其实就是提供邮件传输服务的 SMTP 服务器和客户端。

When forwarding a message into or out of the Internet environment, a
   gateway MUST prepend a Received: line, but it MUST NOT alter in any
   way a Received: line that is already in the header section.

    1
    2
    3

Received 是 在将消息转发到 Internet 环境或从 Internet 环境转发消息时，网关必须预先添加 Received 行，并且它不得以任何方式更改已在标题部分中的 Received 行。
因此排在最后面的 Received 行所指示的地址就是源地址，即 58.88.21.177
P16.

 which uniquely identifies a message within a
          maildrop and which persists across sessions. 

    1
    2

UIDL 即 unique-id listing，可以唯一定位一个消息
P17.

a.

list
+OK 3 14907
1 9125
2 3406
3 2376
.
retr 1
blah blah ...
..........blah
.
dele 1
+OK core mail
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14

b.

list 
+OK 2 5782
2 3406
3 2376
.
retr 2
blah blah ...
..........blah
.
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

c.

list
+OK 2 5782
2 3406
3 2376
.
retr 3
blah blah ...
..........blah
.
retr 2
blah blah ...
..........blah
.
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15

P18.

a.
whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。

b.
Name Server: ns2.google.com
Name Server: ns1.google.com
Name Server: ns4.google.com
Name Server: ns3.google.com
我用的是 linux 上的 whois 命令

c.
在 windows 打开 cmd，使用 nslookup 命令

nslookup 用法:
   nslookup [-opt ...]             # 使用默认服务器的交互模式
   nslookup [-opt ...] - server    # 使用 "server" 的交互模式
   nslookup [-opt ...] host        # 仅查找使用默认服务器的 "host"
   nslookup [-opt ...] host server # 仅查找使用 "server" 的 "host"
比如
nslookup -qt=mx 163.com ns6.nease.net
-qt 可以指示类型

    1
    2
    3
    4
    5
    6
    7
    8

d.

C:\>nslookup www.baidu.com
服务器:  *
Address:  *.*.*.*

非权威应答:
名称:    www.a.shifen.com
Addresses:  111.13.100.92
          111.13.100.91
Aliases:  www.baidu.com

    1
    2
    3
    4
    5
    6
    7
    8
    9

可以看到百度有两个 web 地址

e.
自行查询吧

f.
攻击者可以通过 whois 和 nslookup 查询到目标的 IP 地址，DNS 服务器等

g.
whois 是用来查询域名的IP以及所有者等信息的传输协议，简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。
P19.

a.
以下是 gaia.cs.umass.edu 的查询委托链路：
首先查询根服务器，然后总是选择第一个服务器，最后就可以查到 gaia.cs.umass.edu 的 IP 地址

# dig +norecurse @a.root-servers.net any gaia.cs.umass.edu
...
;; AUTHORITY SECTION:
edu.			172800	IN	NS	f.edu-servers.net.
edu.			172800	IN	NS	a.edu-servers.net.
edu.			172800	IN	NS	g.edu-servers.net.
edu.			172800	IN	NS	l.edu-servers.net.
edu.			172800	IN	NS	c.edu-servers.net.
edu.			172800	IN	NS	d.edu-servers.net.
...

# dig +norecurse @f.edu-servers.net any gaia.cs.umass.edu
...
;; AUTHORITY SECTION:
umass.edu.		172800	IN	NS	ns1.umass.edu.
umass.edu.		172800	IN	NS	ns3.umass.edu.
umass.edu.		172800	IN	NS	ns2.umass.edu.
...

# dig +norecurse @ns1.umass.edu any gaia.cs.umass.edu
...
;; ANSWER SECTION:
gaia.cs.umass.edu.	21600	IN	MX	0 barramail.cs.umass.edu.
gaia.cs.umass.edu.	21600	IN	A	128.119.245.12
...

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25

b.
查询 google.com 时的链路，类似的：
a.edu-servers.net
a.gtld-servers.net
ns2.google.com
P20.

在一段时间内， DNS 服务器缓存中出现最频繁的 web 服务器就是最流行的
P21.

很简单，只需要输入这样的命令dig server，把 server 改成你想测试的网站名，如果 Query time 极短，说明最近可能有人访问过该网站。
P22.

客户-服务器：
与 u 无关， t = max{NF/us, F/di}
N 	t
10 	7500s
100 	50000s
1000 	500000s

P2P：
t = max{F/us, F/di, NF/(us+Nu)}
t 	N 	10 	100 	1000
    u 				
300kps 		7500s 	25000s 	45454.5s
700kps 		7500s 	15000s 	20547.9s
2Mbps 		7500s 	7500s 	7500s
P23.

a.
服务器向每个客户端并行发送文件，此速率为 us/N，因为 us/N <= dmin，所以客户端也以该速率下载。则每个客户端接收完文件的时间为 F / (us / N) = NF / us

b.
仍然考虑服务器向每个客户端并行发送文件，以 dmin 为速率，因为 us/N >= dmin，所以 us >= Ndmin，故服务器可以承受此速率，各服务器以 dmin 为下载速率，故接收时间为 F/dmin

c.
当 us/N <= dmin 时：
        N/us >= 1/dmin
        NF/us >= F/dmin
        此时 t = NF/us = max{NF/us, F/dmin}
当 us/N >= dmin 时：
        N/us <= 1/dmin
        NF/us <= F/dmin
        此时 t = F/dmin = max{NF/us, F/dmin}

因此：得出最小分发时间为 max{NF/us，F/dmin}
P24.

太难了。。。。
P25.

N，N(N-1)/2
P26.

a.
这是可能的，BitTorrent 存在漏洞，不能防止不合作的搭便车行为。
比如 BitThief，它声称自己可以从 BitTorrent swarm 上下载却无需贡献任何资源

b.
他可以在每台主机上都运行客户端，并使他们搭便车，然后将它们收集的块聚合成一个文件，他还可以使不同主机下载不同的块，这是实际上一种 Sybil 攻击。
P27.

对等方 3 可以查它的第二后继对等方 4，使对等方 4 返回它的第一后继对等方 8。
对等方 3 的第一后继是对等方 4，第二后继是对等方 8
P28.

查询会顺时针一直到对等方 5，对等方 5 知道 6 要成为其后继， 6 的后继为 8， 然后 5 向 6 发送 6 的前后继信息，6 接收之后就可以加入 DHT 了。
P29.

对任意 key，可以计算它与所有对等方的距离，将其存放在距离它最近的对等方。
P30.

可能。随机分配标志符而不考虑物理链路，确实会造成错误匹配，逻辑上的“邻居”可能在物理上相距十万八千里。
P31.

a.
会出错

Traceback (most recent call last):
  File "./TCPclient.py", line 5, in <module>
    ClientSocket.connect((ServerName,ServerPort))
ConnectionRefusedError: [Errno 111] Connection refused

    1
    2
    3
    4

b.
没有什么影响

c.
TCP 肯定会报错
P32.

没有必要修改 UDPServer.py。
源端口号 5432，目的端口号 12000
源端口号是随机的
P33.

可以，参考这篇博客 https://blog.csdn.net/williham/article/details/7251091
P34.
P35.

Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。
它是自由软件。
它的一些功能：

    Loadable Dynamic Modules
    Multiple Request Processing modes (MPMs) including Event-based/Async, Threaded and Prefork.
    Highly scalable (easily handles more than 10,000 simultaneous connections)
    Handling of static files, index files, auto-indexing and content negotiation
    .htaccess support[17]
    Reverse proxy with caching[18]
        Load balancing[19] with in-band health checks
        Multiple load balancing mechanisms
        Fault tolerance and Failover with automatic recovery
        WebSocket, FastCGI, SCGI, AJP and uWSGI support with caching
        Dynamic configuration[20]
    TLS/SSL with SNI and OCSP stapling support, via OpenSSL.
    Name- and IP address-based virtual servers
    IPv6-compatible
    HTTP/2 protocol support
    Fine-grained authentication and authorization access control[21]
    gzip compression and decompression
    URL rewriting[22]
    Headers[23] and content[24][25] rewriting
    Custom logging with rotation
    Concurrent connection limiting
    Request processing rate limiting
    Bandwidth throttling
    Server Side Includes[26]
    IP address-based geolocation
    User and Session tracking[27]
    WebDAV
    Embedded Perl, PHP and Lua scripting
    CGI support[28]
    public_html per-user web-pages[29]
    Generic expression parser[30]
    Real-time status views[31]
    XML support[32]
    FTP support (by a separate module) [33]

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34

P36.

键是 torrent 的 infohash，值是存有当前 infohash 指示的文件的 IP 地址

# 第三章

## 复习题3

复习题
R1.

a.
称这个简单的运输层协议为 STP。
在发送端，STP 接收应用程序要发送的数据（不超过 1196 字节）、目的地址、端口号；然后 STP 添加 4 字节头部信息，即端口号；将这 1200 字节的报文段连同目的地址交付给网络层；
在接收端，STP 提取端口和数据，将数据发送给端口所标志的程序。

b.
在头部信息中增加 4 字节的源端口号，将数据减少为 1192 字节。

c.
不。
R2.

略
R3.

y、x
R4.

一些应用程序不想使用 TCP，因为其拥塞控制会降低发送速率。而且应用本身并不需要可靠的数据传输。
R5.

因为今天大多数的防火墙会拦截 UDP
R6.

在应用层添加差错检测，需要程序开发人员在程序中添加一些检测代码
R7.

题目正确的翻译应该是：这两个报文段都将被定向到主机C上的同一个套接字吗？还不如直接 google 翻译呢。那么现在题目要求清楚了，两个报文段都将被定向到主机C上的同一个套接字。根据源 IP 区分不同主机。
R8.

通过不同的欢迎套接字。它们的目的端口都是 80。
R9.

判断究竟是新的分组还是重传
R10.

处理丢包事件，如果丢包可以重传
R11.

RTT 固定的好处就是发送方可以准确判断 ACK 是否丢失，不过它仍需要一个时间固定的定时器。
R12.

a.
接收方丢弃全部分组，之后发送方重传五个分组。

b.
GBN 使用累积确认，因此没有触发重传

c.
只能发送五个，因为窗口大小就是 5
R13.

a.
只重发第一个分组即可

b.
超时重发第一个分组

c.
只能发送五个，因为窗口大小就是 5
R14.

a. 错
b. 错
c. 对
d. 错
e. 对
f. 错
g. 错
R15.

a. 110 - 90 = 20byte
b. 90
R16.

依然是三个，第一个 seq=43 ack=80，第二个 seq=80 ack=44，第三个 seq=44 ack=81
R17.

R/2
R18.

错，设为 cwnd 的一半
R19.

略
习题
P1.

假定 A 向 S 的源端口号为 x， B 向 S 的源端口号为 y
a.
A 向 S 的源端口号为 x， 目的端口号为 23

b.
B 向 S 的源端口号为 y， 目的端口号为 23

c.
S 向 A 的源端口号为 23， 目的端口号为 x

d.
S 向 B 的源端口号为 23， 目的端口号为 y

e.
x y 可能相同

f.
不可能
P2.

从 B 到 C：
   左边的连接：源端口号 80，源 IP 为 B 的 IP；目的端口 26145，目的 IP 为 C 的 IP；
   右边的连接：源端口号 80，源 IP 为 B 的 IP；目的端口 7532，目的 IP 为 C 的 IP；

从 B 到 A：
   源端口号 80，源 IP 为 B 的 IP；目的端口 26145，目的 IP 为 C 的 IP；
P3.

注意应在溢出时向最低位进位：

    01010011  
+   01100110 
————————————
    10111001
+   01110100
————————————
(1) 00101101
+          1
————————————
    00101110

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

其反码为 11010001

使用反码有以下好处：

    不依赖系统是大端还是小端
    计算检验和比较简单快速

接收方检验差错的方法是将三个字节与检验和相加，如果任何一个位为 0，说明出错

1比特的差错肯定会导致结果不同
2比特的差错可能会检测不出，比如题中第一、二字节变为 01010010，01100111，即最后一个比特反转
P4.

a. 00111110
b. 01000000
c. a 中的第一、二字节变为 01011101、01100100
P5.

不能确保，如同上两题讨论的那样
P6.

如果 rdt2.1 发送方正处于“等待来自上层的调用0”，接收方处于“等待来自下层的0”，发送方发送序号为 0 的分组，而接收方正确接收并向发送方发送 ACK；此时发送方处于“等待 ACK 或 NAK 0”，接收方处于“等待下层的 1”，如果此 ACK 损坏，发送方重发序号0的分组，而接收方会发送 NAK，这将导致一个死循环；
其实此接收方并没有标注初始状态，如果发送方初始状态为“等待来自上层的 0”，接收方初始为“等待下层的 1”，也会导致上述死锁。
P7.

ACK 分组没有序号是因为接收方、发送方都不需要该序号。
P8.

可以直接使用 rdt2.2 中的接收方
P9.

图片2张

数据分组损坏
确认分组损坏
P10.

类似于 rdt3.0 的发送方，在 rdt2.1 的发送方上加上 start_timer 以及 timeout 事件即可。timer 的时间要大于最大往返时延。
P11.

如果从“等待来自下层的1”中删除，不会影响正常工作，因为 sndpkt 已经被生成了。
但是如果从“等待来自下层的0”中删除，而且接收方刚刚启动（处于初始状态），sndpkt 是一个错误的值（很可能是一个随机值），那么发送方会认为 ACK 损坏并重发分组，接收方会继续发送错误值，浙江导致一个死锁。
P12.

仅有一个比特差错时，协议正常工作，只不过可能比 rdt3.0 发送方反应更快。
而当定时器时间过短时，每一个超时重发的分组都将会导致正在发送的包重发，这样从第一个包累积到第n个包，分组发送的次数将趋于无穷。
P13.

图片一张

像图片展示的那样，两个 M0 将无法区分
重排序
P14.

分组 x 丢失只能被接收方检测到，且只有 x-1，x+1 都被接收后。如果发送方在发送 x 之后隔较长时间才发送 x+1，那么这段时间 x 将一直不会被重发。
而当数据量较大且很少丢包时，用 NAK 协议发送的数据包的数量明显比 ACK 协议少
P15.

中文版翻译较差，错误极多，无力吐槽。。。这里按英文版的 98% 来做：
U = (nL/R) / (RTT + L/R) > 98%
    解出 n > 2450.98
    因此 n 至少是 2451
P16.

肯定能增加利用率，接收到 ACK0 或 ACK1 之后发送方认为分组已经成功到达，即使事实不是如此。
可能导致许多问题，例如差错出现并不会重发、造成无谓的重发等。
P17.
图1张

B与A类似，只不过初始状态从 receive from A 开始
A
P18.

略
P19.

略
P20.

略
P21.

略
P22.

a.
考虑两种极端情况：

    发送方发送 k-4，k-3，k-2，k-1，接收方都完整得接收并发送 ACK，但 ACK 全都未传到发送方，接收方的期待序号为 k，而发送方窗口序号为 [k-4, k-1]
    如果 ACK 全都传回，则发送方更新 base，其序号为 [k, k+3]

因此序号可能是 [k-4, k+3]

b.
如果接收方期待 k，则它一定将比 k-1 小的 ACK 发送出去了，如果要使发送方发送 k-1，那么它至少已经接收到了 k-5 的 ACK。
因此正在传播回发送方的 ACK 序号可能是 [k-4, k-1]
P23.

设序号为 0（第一个 0），1，…，k-1，0（第二个 0）

对于 SR，要使其序号发生混杂，至少是当接收方刚刚包含第二个 0，即接收方窗口为[k-N-1, 0]，也就是说 k-N (包括 k-N) 之前的都接收过了。要使序号混杂还有一个条件就是第一个 0 在发送方窗口且恰好其 ACK 丢失，需要重发。0(第一个0)~k-N 为 k-N+1 个值，如果窗口长度不足 k-N+1，则第一个 0 和第二个 0 不会同时包含在发送或接收窗口中。
所以窗口长度 N <= k-N，即 N <= k/2

GBN 类似，N <= k 即可
P24.

a.
可能， ACK 还没来得及返回，发送方超时重发，之后发送方接收到 ACK 并移动窗口，那么它之前重发的分组的 ACK 将落在窗口之外

b.
可能，类似 a

c.
是的

d.
是的
P25.

a.
UDP 直接将用户数据打包进报文并立即传输，而 TCP 会将数据写进缓存并可能分成多个报文

b.
TCP 有流量控制和拥塞控制，而 UDP 没有
P26.

a.
注意到 TCP 是字节流编号的， L 的最大值为 2^32 byte

b.
设 N 为报文数：
N=⌈232536⌉=8012999

N=⌈536232​⌉=8012999

总头部长=N∗66byte=528857934byte

总头部长=N∗66byte=528857934byte

总字节数=232byte+528857934byte=4.824∗109byte

总字节数=232byte+528857934byte=4.824∗109byte

t=总字节数155Mbps=249s

t=155Mbps总字节数​=249s
P27.

a.
序号、源、目的端口号分别为 207、302、80

b.
序号、源、目的端口号分别为 207、80、302

c.
127

d.
p27
图片一张
P28.

TCP 让发送方 A 维护一个接收窗口来提供流量控制，主机 B 将实时的 rwnd 值放入发给 A 的报文中，通知 B 的缓存大小。A 确保 LastByteSent - LastByteAcked <= rwnd，当缓存不足时，将暂停向 B 发送数据
P29.

a.
防止有攻击者发动 SYN 洪泛攻击

b.
不能。当服务器使用 SYN cookie 时，它不维护 cookie 或其他信息，因此半开连接不可行。攻击者并不知道某个服务器和某 IP 对应的初始序列号，因为那个秘密数只有服务器知道。

c.
理论上可行
P30.

a.
超时值是固定的，单一得增加有限缓存的长度，会导致未丢失的分组被重传

b.
有助于。
P31.

略，自己慢慢算算吧
P32.

a.
EstimatedRTT’
= 0.9 ( 0.9 ( 0.9 ( 0.9 EstimatedRTT + 0.1 SampleRTT1 ) + 0.1 SampleRTT2 ) + 0.1 SampleRTT3 ) + 0.1 SampleRTT4
= 0.9^4 EstimatedRTT + 0.1 SampleRTT4 + 0.9 * 0.1 SampleRTT3 + 0.9^2 * 0.1 SampleRTT2 + 0.9^3 * 0.1 SampleRTT1

b.
推广到 n：
EstimatedRTT’ = 0.9^n EstimatedRTT + 0.9^(n-1) * 0.1 SampleRTT1 + 0.9^(n-2) * 0.1 SampleRTT2 + … + 0.1 SampleRTTn

c.
根据上式：
EstimatedRTT′=0.9nEstimatedRTT+110∑ni=10.9n−iSampleRTTi

EstimatedRTT′=0.9nEstimatedRTT+101​∑i=1n​0.9n−iSampleRTTi​

可以看出 i 越小，SampleRTTi
SampleRTTi​ 对 EstimatedRTT′

EstimatedRTT′ 的影响越小，且其权重呈指数形式锐减
P33.

假设传递分组 1 到目的地，超时后源又重发分组 1 的副本分组 2；如果分组 1 的 ACK 返回到源，则源可能将它作为分组 2 的 ACK，从而计算了一个错误的 RTT
P34.

SendBase - 1 <= LastByteRcvd
LastByteRvcd 是刚到达 B 的编号， SendBase - 1 是已经到达 B 的编号
P35.

y 之前的所有字节都被接收，因此 y-1 <= LastByteRcvd
P36.

考虑当分组错序到达会发生什么，分组 1 正确到达，目的地发送 ACK，分组 3 提前于分组 2 到达，发送一个冗余 ACK，这将导致发送方重传分组 2，即使分组 2 并未丢失
P37.

a.
GBN：
A：首先发送分组 12345，后来重发 2345，总共 9 个分组
B：首先发送 ACK 1111，后来发送 2345，总共 5 个 ACK

SR：
A：首先发送分组 12345，后来重发 2，总共 6 个分组
B：首先发送 ACK 1345，后来发送 2，总共 5 个 ACK

TCP：
A：首先发送分组 12345，后来重发 2，总共 6 个分组
B：首先发送 ACK 2222，后来发送 6，总共 5 个 ACK

b.
GBN、SR 需要等待超时，而 TCP 使用快速重传，故 TCP 最快
P38.

是的
P39.

λ’in 超过 R/2，会导致更多的丢包以及重传，λout 可能会下降
P40.

a. [1, 6] 和 [23, 26]

b. [6, 16] 和 [17, 22]

c. 三个冗余 ACK

d. 超时

e. 32

f. 42/2 = 21

g. 29/2 = 14

h. 分组 1 (p1) 在传输轮回 1 (t1) 中发送，p2~p3 在 t2 中发送，p4~p7 在 t3 中发送，p8~p15 在 t4，p16~p31 在 t5，p32~p63 在 t6，p64~p96 在 t7,
因此分组 70 在第 7 个传输轮回内发送

i. ssthresh = 4，cwnd = ssthresh + 3MSS = 7

j. 在第16个传输轮回时，ssthresh = cwnd/2 = 21，cwnd = 1 并进入慢启动状态，则在第19个传输轮回中，ssthreash = 21，cwnd = 4

k. t17：1个，t18：2个，t19：4个，t20：8个，t21：16个，t22：21个
1 + 2 + 4 + 8 + 16 + 21 = 52 个
P41.
图片一张
从图中可以看出，这不是一种平等算法
p41

P42.

超时仅能减缓 分组未丢失超时重传 这种情况，不能阻止 TCP 向可能出现拥塞的端到端路径上继续发送更多的新的分组。
P43.

流量控制将无法适用，因为接受缓存足够大。
没有丢包、没有超时，因此拥塞控制也无法适用。
无需适用任何措施，当发送缓存满载时，自动就慢下来了。
P44.

a.
每个 RTT 加 1 个 MSS，因此需要 6 个 RTT

b.
6 + 7 + 8 + 9 + 10 + 11 = 51 MSS
平均吞吐量为 51MSS / 6RTT = 8.5 MSS/RTT
P45.

a.
从 W/2RTT 到 W/RTT 期间总共发送的分组数：
W2+(W2+1)+(W2+2)+...+W=(W+W2)(W−W2+1)2=38W2+34W

2W​+(2W​+1)+(2W​+2)+...+W=2(W+2W​)(W−2W​+1)​=83​W2+43​W

仅丢了一个包，因此丢包率L=138W2+34W

仅丢了一个包，因此丢包率L=83​W2+43​W1​

b.
当W足够大，38W2>>34W，此时L≈138W2=8/3W2

当W足够大，83​W2>>43​W，此时L≈83​W21​=8/3W2

得出W≈8/3L−−−−√
得出W≈8/3L

​

则平均吞吐率为=0.75WRTT≈1.22MSSRTTL√
则平均吞吐率为=RTT0.75W​≈RTTL

​1.22MSS​
P46.

a.
最大窗口长度 W 受限于链路速率：W * MSS / RTT = 10Mbps
得到 W = 125

b.
从 W/2 到 W：
平均窗口长度为 0.75W = 94
平均吞吐量为 94 * 1500 * 8 / 0.15 = 7.52Mbps

c.
W’ = W/2 + 3 = 65
从 W’ 到 W：
(125-65)*150ms = 9s
P47.

不会
P48.

a.
W*MSS/RTT = 10Gbps
W = 125000

b.
7.52Gbps

c.
156.2min
P49.

已知 TCP 平均吞吐量 D=1.22MSSRTTL√
D=RTTL

​1.22MSS​

L=(1.22MSSRTT∗D)2

L=(RTT∗D1.22MSS​)2

1L为丢包后(的那一刻)TCP发送的总分组数(因为只丢了一个包)

L1​为丢包后(的那一刻)TCP发送的总分组数(因为只丢了一个包)

则MSSL=T∗D,T=D∗RTT21.222MSS

LMSS​=T∗D,T=1.222MSSD∗RTT2​

因此 T 是 D 的函数
P50.

每秒发送最多 30 个报文段，即每 100ms 最多发送 3 个，每 50ms 最多发送 1 个；无论何时发生丢包，假定 C1 每 100ms 调整一次窗口， C2 每 50ms 调整一次。
a.
t/ms 	C1.cwnd/报文段 	C2.cwnd/报文段
0 	10 	10
50 	5↓ （↓ 的意思是因丢包而减少一半） 	10
100 	2↓ 	5↓
150 	1↓ 	5
200 	1▲ （▲ 的意思是无法继续减少） 	2↓
250 	1▲ 	2
300 	1▲ 	1↓
350 	2↑（↑ 的意思是加性增） 	1
400 	1↓ 	1▲
450 	2↑ 	1
500 	1↓ 	1▲
550 	2↑ 	1
600 	1↓ 	1▲
650 	2↑ 	1
700 	1↓ 	1▲
750 	2↑ 	1
800 	1↓ 	1▲
850 	2↑ 	1
900 	1↓ 	1▲
950 	2↑ 	1
1000 	1↓ 	1▲

因此它们的拥塞窗口为 1、1

b.
C1 明显比 C2 占有的带宽多一些，是 C2 的三倍
P51.

类似上一题
a.
都是2
t/ms 	C1.cwnd/报文段 	C2.cwnd/报文段
0 	15 	10
100 	7↓ 	5↓
200 	3↓ 	2↓
300 	1↓ 	1↓
400 	2↑ 	2↑
500 	1↓ 	1↓
600 	2↑ 	2↑
700 	1↓ 	1↓
800 	2↑ 	2↑
900 	1↓ 	1↓
1000 	2↑ 	2↑
1100 	1↓ 	1↓
1200 	2↑ 	2↑
1300 	1↓ 	1↓
1400 	2↑ 	2↑
1500 	1↓ 	1↓
1600 	2↑ 	2↑
1700 	1↓ 	1↓
1800 	2↑ 	2↑
1900 	1↓ 	1↓
2000 	2↑ 	2↑
2100 	1↓ 	1↓
2200 	2↑ 	2↑

b.
是的

c.
是的，都是2

d.
不利于改善利用率
当 C1 C2 的窗口大小都为 1 时，这条链路无法满载。
可以增设一个缓冲区，在缓冲区溢出之前随机丢弃一些分组。主动队列管理，随机早期检测等都用到了此种方法。
P52.

1.
类似 P45：

S=W2+W2(1+a)+W2(1+a)2+...+W

S=2W​+2W​(1+a)+2W​(1+a)2+...+W

设 W2(1+a)n=W

2W​(1+a)n=W ：

得 n=log1+a2

n=log1+a​2

从而 S=W(2a+1)2a

S=2aW(2a+1)​

则丢包率 L=1S=2aW(2a+1)

L=S1​=W(2a+1)2a​

2.
从 W/2 增加到 W 需要的时间：

n∗RTT=log1+a2∗RTT

n∗RTT=log1+a​2∗RTT

跟吞吐量无关
P53.

根据公式：

D=1.22MSSRTTL√
D=RTTL

​1.22MSS​

L=(1.22MSSRTT∗D)2=(1.22∗1500byte0.1s∗10Gbps)2=(14640109)2=2∗10−10

L=(RTT∗D1.22MSS​)2=(0.1s∗10Gbps1.22∗1500byte​)2=(10914640​)2=2∗10−10

而当 D’ = 100Gbps 时：

L=(146401010)2=2∗10−12

L=(101014640​)2=2∗10−12
P54.

优点是无需经历慢启动过程
缺点是 t1 时刻的 cwnd 和 ssthresh 比较陈旧，不能正确反映 t2 时刻的线路拥塞状态
P55.

a.
Y

b.
可以确认，SYNACK 将发到 Y，攻击者无法得知初始的序号，也就无法发回正确的 ACK
P56.

略

# 第四章

复习题
R1.

网络层分组叫做数据报。路由器处于第三层的，链路交换机是第二层
R2.

数据报网络中两个最重要的功能是：转发和路由，虚电路网络中增加了一项：连接建立
R3.

转发是指在路由器内部将输入端口的分组转移到正确的输出端口；而路由是指路由器决定从源到目的地的路径
R4.

是的
R5.

略
R6.

IP电话等
R7.

有了影子副本，就可以在每个输入端口本地进行转发决策，而无需基于每个数据包调用集中式路由处理器，从而避免集中处理瓶颈。
R8.

分别是内存交换，总线交换和纵横结构。只有纵横结构可以并行转发。
R9.

如果分组到达的速率大于交换结构的速率，那么就会造成排队，最终队列越来越长，导致分组丢失。解决方法就是提升交换结构的速率至 n 倍的输入线路速率，n 是端口数
R10.

假设输入速率和输出速率一致，当分组到达单个输出端口的速率大于线路速率时，就会造成排队，最终队列越来越长，导致分组丢失。增加交换结构的速率对减缓排队现象没有任何帮助。
R11.

HOL：head-of-the-line
HOL阻塞的意思是，队列最前端的分组由于某种原因被阻塞，它后面的分组即使可以被转发结构转发，也需要等到最前端被转发之后才可以被转发。
它出现在输入端口。
R12.

路由器有 IP 地址，每一个接口都有一个 IP
R13.

11011111.00000001.00000011.00011011
R14.

略
R15.

8、3
R16.

20+20/20+20+40 = 50%
50% 的开销
R17.

IP 头部中“协议”字段，可以用来判断是 TCP 或 UDP 或其他。
R18.

无线路由器内置 DHCP 服务器，使用 DHCP 分发 IP 地址等。当然了，路由器也使用 NAT，因为只有一个公网 IP 要分配个五台 PC。
R19.

略
R20.

同意，因为 IPv6 的数据报被封装在 IPv4 的数据报中
R21.

链路状态路由协议是层次式的，网络中的路由器并不向邻居传递“路由项”，而是通告给邻居一些链路状态。与距离矢量路由协议相比，链路状态协议对路由的计算方法有本质的差别。距离矢量协议是平面式的，所有的路由学习完全依靠邻居，交换的是路由项。链路状态协议只是通告给邻居一些链路状态。运行该路由协议的路由器不是简单地从相邻的路由器学习路由，而是把路由器分成区域，收集区域的所有的路由器的链路状态信息，根据状态信息生成网络拓扑结构，每一个路由器再根据拓扑结构计算出路由。
R22.

路由器被组织成 AS，在一个 AS 中，所有路由器运行相同的AS内部协议，在跨越 AS 时需要使用AS间协议。
R23.

没有必要
R24.

不会改变，因为初始表中通过 B 到 z 跳数是 7，然而来自 A 的通告到 z 需要 11 跳，因此表不会改变。
R25.

RIP 路由选择更新信息在邻居间通过使用一种 RIP 响应报文来交换，大约 30 秒交换一次。
而 OSPF 向 AS 内部所有其他路由广播路由选择信息，不仅仅是邻居，每当一条链路的状态发生变化时，路由器就会广播链路状态信息，即使未发生变化，它也周期性地广播链路状态。
R26.

路径上的 AS 序列
R27.

请看课本 P268
R28.

略
R29.

子网是较大型网络的一部分，不包含路由器，其边界定义为路由器和主机的接口。
前缀是 CDIR 地址的网络部分。
带有 属性 的 前缀 叫做一条 BGP 路由。
R30.

路由器使用 AS-PATH 来检测和防止循环通告，也使用它在多条路径中选择相同前缀。
NEXT-HOP 指示沿给定前缀的通告路径（位于接收通告的 AS 之外）的第一路由器的IP地址。
R31.

举个例子，ISP B 不想传输从 ISP A 和 C 之间的流量，它就可以不向 A 和 C 通告这条路由路径。
R32.

使用单播模拟广播，效率低，它可能会在同一条链路上多次发送相同的数据包；而且寻址困难，源必须知道所有接收方的地址
R33.

a. 无控制洪泛和受控洪泛都可能接收到同一个分组的多个副本
b. 无控制洪泛可能通过相同的出链路转发多个分组的副本
R34.

不需要
R35.

IGMP 为主机提供了一种方式，让它通知第一跳路由器，本机上的一个应用程序想要加入一个特定的多播组。 IGMP 协议只运行在主机和它的第一跳多播路由器之间。然后由多播路由器与其他多播路由器协同工作，即运行多播路由选择协议，以确保加入主机的多播组的数据被路由到适当的最后一跳路由器，并从那里路由到主机。
R36.

组共享的树：所有的发送方都在同一条路由树上发送多播流量
基于源的树：每个源都有自己的一颗多播路由选择树
习题
P1.

a.
数据报体系更好，使用虚电路当出现无法工作的路由器时，需要重新建立连接。而数据报体系更加“灵活”，路由表可以通过距离向量算法或链路状态算法更新。

b.
虚电路体系更好，虚电路是面向连接的，路由器维持连接状态信息，可以为源到目的的会话提供固定容量。

c.
数据报将有更多的流量控制开销，这是由数据报中各种数据包报头造成的
P2.

a. 2^8 = 256
b. 中文版翻译看不懂什么意思，较为清晰的翻译应该是：在连接建立时由某个中央结点决定路径和 VC 号。按照题意，中央结点只需在 [0, 2^8-1] 之间选择一个未被使用的即可。这种虚电路中的 VC 号不可能比(a)中确定的少
c. 每条链路都能独立分配 VC 号，路由器将这些对应的 VC 号写入转发表，当特定 VC 号的分组到达后，将其 VC 号替换为对应的 VC 号并转发
P3.

入接口、入VC号、出接口、出VC号
目的地址范围、输入接口
P4.

a.
目的地址 	输出接口
H3 的 IP 	3

b.
转发只能基于目的地址，因此无法实现。实际上英文版上是“trick question”。

c.
A 	入接口 	入VC号 	出接口 	出VC号
	1 	16 	3 	27
	2 	3 	4 	58

d.
B 	入接口 	入VC号 	出接口 	出VC号
	1 	27 	2 	52
C 	入接口 	入VC号 	出接口 	出VC号
	1 	58 	3 	22
D 	入接口 	入VC号 	出接口 	出VC号
	1 	52 	3 	19
	2 	22 	3 	30
P5.
P6.

connection-oriented service & connection service

在虚电路中，每个路径上的路由器都维持连接状态信息。
而在面向连接的运输层服务中，由端系统维持连接状态信息。运输层服务通过无连接的网络层传输，例如 TCP 通过 IP 传输，中间路由器并不知道自己在维持连接。
P7.

a. 不能
b. 可能
c. 不能
P8.

书上有误，应该是“n个分组到达n个输入端口”，把“出”改成“入”。

(n-1)D、(n-1)D、0
D 为输入（输出）时延，内存、总线的时延是一致的，有 n 个分组在排队，即使是发往不同的输出端口。
P9.

中文版的字母看不清，从上到下、从左到右依次是 X X Y Z Y

需要三个时隙，例如时隙 1 发送最上面的 X 和中间的 Y，时隙 2 发送中间的 X 和下面的 Y，时隙 3 发送下面的 Z。
最坏也需要三个时隙，时隙 1 发送上面的 X 和中间或下面的 Y，时隙 2 也能发送两个，时隙 3 发送最后剩余的 1 个。
P10.

a.
难点在接口 2 的写法
前缀匹配 	链路接口
11100000 00 	0
11100000 01000000 	1
1110000 	2
11100001 1 	3
其他 	3

b.
第一个为其他，选择了接口 3；第二个选择 2；第三个选了 3
P11.

接口 0：从 00000000 到 00111111，共 2^6=64
接口 1：从 01000000 到 01011111，共 2^5=32
接口 2：从 01100000 到 01111111，从 10000000 到 10111111，共 2^5 + 2^6 = 96
接口 3：从 11000000 到 11111111，共 2^6 = 64
P12.

与上题类似，略
P13.

子网 1：223.1.17.192/26
子网 2：223.1.17.0/25
子网 3：223.1.17.128/28
可以多种不同分配方案
P14.

与下题类似，略
P15.
目的地址 	接口
224.0/10 	0
224.64/16 	1
224/7 	2
225.128/9 	3
其他 	3
P16.

地址范围为 128.119.40.128~128.119.40.191，任意给出一个即可

2^6=64 64/4=16 即每个子网有16个IP

子网 1：128.119.40.64/28
子网 2：128.119.40.80/28
子网 3：128.119.40.96/28
子网 4：128.119.40.112/28
P17.

略
P18.

whois 不能用来确定某个特定 IP 地址的确定位置。但是可以使用 www.maxmind.com。
P19.

⌈2400−20700−20⌉=4

⌈700−202400−20​⌉=4
因此需要 4 个分片。每个 IP 数据报都有相同的标识号 422；4个数据报的偏移分别是 0、85、170、255；等等。
P20.

与上题类似，略
P21.

a.
可以随意分配
主机 192.168.1.1 192.168.1.2 192.168.1.3，路由器接口地址 192.168.1.4

b.
NAT 转换表：
WAN端 	LAN端
24.34.112.235 5001 	192.168.1.1 3345
24.34.112.235 5002 	192.168.1.1 3346
24.34.112.235 5003 	192.168.1.2 3345
24.34.112.235 5004 	192.168.1.2 3346
24.34.112.235 5005 	192.168.1.3 3345
24.34.112.235 5006 	192.168.1.3 3346
P22.

a.
既然我们可以捕获所有分组，那么只需统计 IP 分组的标识号即可

b.
不能正常工作
P23.

Arwold 和 Bernard 都位于 NAT 之后，任一方都不能与对方建立连接
P24.

略
P25.

略
P26.
步骤 	N’ 	y 花费、路径 	z 花费、路径 	v 花费、路径 	w 花费、路径 	u 花费、路径 	t 花费、路径
0 	x 	6，xy 	8，xz 	3，xv 	6，xw 	∞ 	∞
1 	xv 	6，xy 	8，xz 		6，xw 	6，xvu 	7，xvt
2 	xvy 		8，xz 		6，xw 	6，xvu 	7，xvt
3 	xvyw 		8，xz 			6，xvu 	7，xvt
4 	xvywu 		8，xz 				7，xvt
5 	xvywut 		8，xz 				
6 	xvywutz 						
P27.

略
P28.
从…到…的费用 	u 	v 	x 	y 	z
v 	∞ 	∞ 	∞ 	∞ 	∞
x 	∞ 	∞ 	∞ 	∞ 	∞
z 	∞ 	6 	2 	∞ 	∞

第一次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	∞ 	6
x 	∞ 	3 	0 	3 	2
z 	7 	5 	2 	5 	0

第二次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	3 	5
x 	4 	3 	0 	3 	2
z 	6 	5 	2 	5 	0

第三次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	3 	5
x 	4 	3 	0 	3 	2
z 	6 	5 	2 	5 	0
P29.

算法收敛于 最长的无环路的距离减一 次迭代
P30.

略
P31.

略
P32.

减少费用不会出现无穷计数，因为不会造成路由选择环路。
连接两个结点相当于将无穷的费用减少为链路的费用。
P33.

每一次结点距离向量的更新都是基于 Bellman-Ford 公式，只会不断减少它们的距离向量。如果距离向量不再减少，即不再更新，在有限步内它们就会稳定下来。
P34.

a题翻译有误，应为 w、y、z 向彼此告知它们到 x 的距离。
a.
z 	到 x 的距离
告诉 w 	∞
告诉 y 	6
y 	到 x 的距离
告诉 w 	4
告诉 z 	4
w 	到 x 的距离
告诉 y 	∞
告诉 z 	5

b.
存在无穷计数问题。
y 计算它到 x 的距离 Dy(x) = min{ c(y,x)+Dx(x), c(y,z)+Dz(x)} = min{60, 6+3} = 9
然而这个值是错误的，将导致一个路由选择环路。

c.
将 y 和 z 切断
P35.

通过 AS-PATH
P36.

课本上有介绍，首先选择的是本地偏好值中的路由，然后才是最短 AS 路径
P37.

a. eBGP
b. iBGP
c. eBGP
d. iBGP
P38.

a. I1，因为 I1 离 1c 近
b. I2，虽然跨越的 AS 的数量相同，但是 I2 离 NEXT-HOP 路由器更近
c. I1，因为经 I1 的话 AS-PATH 更小
P39.

略
P40.

x 的视图：
x的视图
y 的视图：
y的视图
P41.

比如 BitTorrent 或其他 P2P 应用
P42.

A 向 B 通告两个路由：AS-PATH 为 A-W 和 A-V
A 向 C 通告一个路由： A-V
C 收到的 AS-PATH 为：B-A-W，B-A-V，A-V
P43.

Z 想传送来自 Y 的流量，因此 Z 向 Y 发送路由通告，但是 Z 无法阻止 Y 向 X 通告此路径，最终 X 也将向 Z 传送流量
P44.

可以用 Kruskal 或 Prim 算法 计算最小生成树
P45.

如果路由器二叉树是一个满二叉树：
向一个接收方发送一个分组的费用是 5，因此单播模拟的总费用是 5*32=160
网络层广播将报文复制并发送其副本，因此费用为 2+4+8+16+32 = 62

当拓扑的形状是一条直线时，所有接收方都连在距离发送方最远的结点上，费用相差最大
P46.

p46
可能有多种画法。
设加粗的路径是 A 的最小生成树。 这时 B 将收到来自 A、C、D 的广播报文。
P47.

略
P48.

略
P49.

p49
P50.

略
P51.

例如：
1
对于 Dijkstra（源为A）:
2
对于最小生成树：
3
P52.

3*2^(t-1)
P53.

协议必须建立在应用层才行，举例来说，应用程序可以在应用层报文中周期性地向其他组成员多播它的身份。
P54.

一个最简单的应用层协议设计，就是所有成员都向所有其他成员多播自己得身份，在带内发送报文即可。
P55.

D类地址得第一个字节以“1110”开始，因此可用位为32-4=28，空间为 N=2^28
两个不同组选择相同地址的概率=1/N=2^-28
1000个组不冲突的概率=N(N-1)(N-2)…(N-999)/N^1000
冲突概率=1-N(N-1)(N-2)…(N-999)/N^1000

# 第五章













[Back to Index](#目录)

## 问题5

P1、

y-x-u,y-x-v-u,y-x-w-u,y-x-w-v-u,



P2、

P3、

|step|$N^{'}$|D(t),p(t)|D(u),p(u)|D(v),p(v)|D(w),p(w)|D(y),p(y)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|x|$\infty$|$\infty$|3,x|6,x|6,x|8,x|
|1|xv|7,v|6,v|3,x|6,x|6,x|8,x|
|2|xvu|7,v|6,v|3,x|6,x|6,x|8,x|
|3|xvuw|7,v|6,v|3,x|6,x|6,x|8,x|
|4|xvuwy|7,v|6,v|3,x|6,x|6,x|8,x|
|5|xvuwyt|7,v|6,v|3,x|6,x|6,x|8,x|
|6|xvuwytz|7,v|6,v|3,x|6,x|6,x|8,x|

P4、

a)

|step|$N^{'}$|D(x),p(x)|D(u),p(u)|D(v),p(v)|D(w),p(w)|D(y),p(y)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|x|$\infty$|2,t|4,t|$\infty$|7,t|$\infty$|
|1|xv|$\infty$|2,t|4,t|5,u|7,t|$\infty$|
|2|xvu|7,v|2,t|4,t|5,u|7,t|$\infty$|
|3|xvuw|7,v|2,t|4,t|5,u|7,t|$\infty$|
|4|xvuwy|7,v|2,t|4,t|5,u|7,t|15,x|
|5|xvuwyt|7,v|2,t|4,t|5,u|7,t|15,x|
|6|xvuwytz|7,v|2,t|4,t|5,u|7,t|15,x|

b)

|step|$N^{'}$|D(x),p(x)|D(t),p(t)|D(v),p(v)|D(w),p(w)|D(y),p(y)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|x|$\infty$|2,u|3,u|3,u|$\infty$|$\infty$|
|1|xv|$\infty$|2,u|3,u|3,u|9,t|$\infty$|
|2|xvu|6,v|2,u|3,u|3,u|9,t|$\infty$|
|3|xvuw|6,v|2,u|3,u|3,u|9,t|$\infty$|
|4|xvuwy|6,v|2,u|3,u|3,u|9,t|14,x|
|5|xvuwyt|6,v|2,u|3,u|3,u|9,t|14,x|
|6|xvuwytz|6,v|2,u|3,u|3,u|9,t|14,x|

c)

|step|$N^{'}$|D(x),p(x)|D(u),p(u)|D(t),p(t)|D(w),p(w)|D(y),p(y)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|v|3,v|3,v|4,v|4,v|8,v|$\infty$|
|1|vx|3,v|3,v|4,v|4,v|8,v|11,x|
|2|vxu|3,v|3,v|4,v|4,v|8,v|11,x|
|3|vxut|3,v|3,v|4,v|4,v|8,v|11,x|
|4|vxutw|3,v|3,v|4,v|4,v|8,v|11,x|
|5|vxutwy|3,v|3,v|4,v|4,v|8,v|11,x|
|6|vxutwyz|3,v|3,v|4,v|4,v|8,v|11,x|

d)

|step|$N^{'}$|D(x),p(x)|D(u),p(u)|D(v),p(v)|D(t),p(t)|D(y),p(y)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|w|6,w|3,w|4,w|$\infty$|$\infty$|$\infty$|
|1|wu|6,w|3,w|4,w|5,u|$\infty$|$\infty$|
|2|wuv|6,w|3,w|4,w|5,u|12,v|$\infty$|
|3|wuvt|6,w|3,w|4,w|5,u|12,v|$\infty$|
|4|wuvtx|6,w|3,w|4,w|5,u|12,v|14,x|
|5|wuvtxy|6,w|3,w|4,w|5,u|12,v|14,x|
|6|wuvtxyz|6,w|3,w|4,w|5,u|12,v|14,x|

e)

|step|$N^{'}$|D(x),p(x)|D(u),p(u)|D(v),p(v)|D(w),p(w)|D(t),p(t)|D(z),p(z)|
|-|-|-|-|-|-|-|-|
|0|y|6,y|$\infty$|8,y|$\infty$|7,y|12,y|
|1|yx|6,y|$\infty$|8,y|12,x|7,y|12,y|
|2|yxt|6,y|9,t|8,y|12,x|7,y|12,y|
|3|yxtv|6,y|9,t|8,y|12,x|7,y|12,y|
|4|yxtvu|6,y|9,t|8,y|12,x|7,y|12,y|
|5|yxtvuw|6,y|9,t|8,y|12,x|7,y|12,y|
|6|yxtvuwz|6,y|9,t|8,y|12,x|7,y|12,y|

f)

|step|$N^{'}$|D(x),p(x)|D(u),p(u)|D(v),p(v)|D(w),p(w)|D(y),p(y)|D(t),p(t)|
|-|-|-|-|-|-|-|-|
|0|z|8,z|$\infty$|$\infty$|$\infty$|12,z|$\infty$|
|1|zx|8,z|$\infty$|11,x|14,x|12,z|$\infty$|
|2|zxv|8,z|14,v|11,x|14,x|12,z|15,v|
|3|zxvy|8,z|14,v|11,x|14,x|12,z|15,v|
|4|zxvyu|8,z|14,v|11,x|14,x|12,z|15,v|
|5|zxvyuw|8,z|14,v|11,x|14,x|12,z|15,v|
|6|zxvyuwt|8,z|14,v|11,x|14,x|12,z|15,v|


P5、

||||值||||
|-|-|-|-|-|-|-|
|||u|v|x|y|z|
||v|$\infty$|$\infty$|$\infty$|$\infty$|$\infty$|
|从|x|$\infty$|$\infty$|$\infty$|$\infty$|$\infty$|
||z|$\infty$|6|2|$\infty$|0|

||||值||||
|-|-|-|-|-|-|-|
|||u|v|x|y|z|
||v|1|0|3|$\infty$|6|
|从|x|$\infty$|3|0|3|2|
||z|7|5|2|5|0|

||||值||||
|-|-|-|-|-|-|-|
|||u|v|x|y|z|
||v|1|0|3|3|5|
|从|x|4|3|0|3|2|
||z|6|5|2|5|0|

||||值||||
|-|-|-|-|-|-|-|
|||u|v|x|y|z|
||v|1|0|3|3|5|
|从|x|4|3|0|3|2|
||z|6|5|2|5|0|

P6、这个问题的措辞有点含糊。我们的意思是，“第一次运行算法时的迭代次数”(也就是说，假设节点最初拥有的唯一信息是其最近的邻居的成本)。我们假设该算法是同步运行的(即，在一个步骤中，所有节点同时计算它们的距离表，然后交换表)。

在每次迭代时，节点与其邻居交换距离表。因此，如果您是节点A，而您的邻居是B，则B的所有邻居(它们都是您的一两跳)在一次迭代后(即B告诉他们它对您的成本后)将知道一到两个跳到您的最短代价路径。

d是网络的“直径”--网络中任何两个节点之间最长的无环路路径的长度。使用上面的推理，经过d-1迭代后，所有节点都将知道d或更少跳到所有其他节点的最短路径代价。由于任何大于d跳的路径都会有循环(因此比去掉循环的路径花费更大)，该算法最多会在d-1迭代中收敛。

旁白：如果DV算法是由于链路成本的变化而运行的，则在收敛之前，所需迭代次数不存在先验界，除非还指定了链路成本的约束。

P7、

a)Dx(w) = 2, Dx(y) = 4, Dx(u) = 7 

b)首先考虑如果c(x，y)发生变化会发生什么。如果c(x，y)变大或变小(只要c(x，y)>=1)，那么从x到u的最小成本路径仍然至少要花费7。因此c(x，y)的改变(如果c(x，y)>=1)不会使x通知其邻居。

如果c(x，y)=$\sigma$<1，那么最小成本的路径现在通过y，并有成本$\sigma$+6。

现在考虑如果c(x，w)改变。如果c(x，w)=$\varepsilon$<=1，那么u的最小成本路径将继续通过w，其成本将更改为5+$\varepsilon$; x将通知它的邻居这个新的成本。如果c(x，w)=$\sigma$>6，那么最小成本路径现在经过y并花费了11；x将再次通知它的邻居这个新成本。

c)链路成本c(x，y)(以及只要c(x，y)>=1)中的任何更改都不会导致x通知其邻居关于u的新的最小成本路径。

P8、

结点x表

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|0|3|4|
|从|y|$\infty$|$\infty$|$\infty$|
||z|$\infty$|$\infty$|$\infty$|

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|0|3|4|
|从|y|3|0|6|
||z|4|6|0|

结点y表

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|$\infty$|$\infty$|$\infty$|
|从|y|3|0|6|
||z|$\infty$|$\infty$|$\infty$|

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|0|3|4|
|从|y|3|0|6|
||z|4|6|0|

结点z表

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|$\infty$|$\infty$|$\infty$|
|从|y|$\infty$|$\infty$|$\infty$|
||z|4|6|0|

|||值|||
|-|-|-|-|-|
|||x|y|z|
||x|0|3|4|
|从|y|3|0|6|
||z|4|6|0|

P9、不，这是因为降低链路成本不会导致循环(由该链路的两个节点之间的下一跳关系引起)。将两个节点连接到一个链路相当于将链路重量从无限降到有限权。

P10、在每一步中，节点距离向量的每一次更新都是基于Bellman-Ford方程，即只减少距离向量中的这些值。价值没有增加。如果没有更新，则不会发送消息。因此，D(X)是不增加的。由于这些代价是有限的，那么最终距离向量将稳定在有限的步骤。

P11、

a)
| | |
|-|-|
|Router z |Informs w, Dz(x)=$\infty$|
| |Informs y, Dz(x)=6 |
|Router w |Informs y, Dw(x)=$\infty$|
|| Informs z, Dw(x)=5 |
|Router y |Informs w, Dy(x)=4 |
|| Informs z, Dy(x)=4 |

b) 是的，会有一个数不胜数到无穷大的问题。下表显示了路由收敛过程。假设在t0时间发生链路成本更改。在时间T1，y更新其距离向量并通知邻居w和z。在下表中，“$\to$”表示“通知”。

|time |t0 |t1 |t2 |t3 |t4 |
|-----|---|---|---|---|---|
|Z | $\to$ w, Dz(x)=$\infty$||No change |$\to$ w, Dz(x)=$\infty$||
||$\to$y, Dz(x)=6|||$\to$y, Dz(x)=11 ||
|W|$\to$y, Dw(x)=$\infty$||$\to$y, Dw(x)=$\infty$| |No change |
||$\to$z,Dw(x)=5||$\to$z,Dw(x)=10 ||
|Y|$\to$w, Dy(x)=4 |$\to$w, Dy(x)=9 ||No change|$\to$w, Dy(x)=14 |
||$\to$z, Dy(x)=4 |$\to$z, Dy(x)=$\infty$|||$\to$z, Dy(x)=$\infty$|

我们看到w，y，z在计算路由器x的开销时形成一个循环。如果我们继续上面表中所示的迭代，那么在T27，z通过它与x的直接联系检测到它对x的最小成本是50。在T29，w通过z得知它对x的最小成本为51。在t30，y将其最小成本更新为52(通过w)。最后，在T31，没有更新，路由是稳定的。

|time |t27 |t28 |t29 |t30 |t31|
|-----|----|----|----|----|---|
|Z |$\to$w, Dz(x)=50 ||||via w, $\infty$|
||$\to$y, Dz(x)=50|||| via y, 55 |
||||||via z, 50 |
|W ||$\to$y, Dw(x)= |$\to$y, Dw(x)=51 ||via w, $\infty$|
||| $\to$z, Dw(x)=50 |$\to$z, Dw(x)= $\infty$ ||via y, $\infty$|
||||||via z, 51 |
|Y| |$\to$w, Dy(x)=53| |$\to$w, Dy(x)= $\infty$ |via w, 52 |
|| |$\to$z, Dy(x)= $\infty$ ||$\to$z, Dy(x)= 52 |via y, 60 |
||||||via z, 53 |

c)切断y和z之间的连接。

P12、由于在BGP、循环中从AS到目的地都提供了完整的路径信息检测是简单的-如果BGP对等体接收到包含自己的AS号的路由AS路径，然后使用该路由将导致环路。

P13、选择的路径不一定是最短的路径.回顾一下，在路线选择过程中有许多问题需要考虑。由于经济原因，较长的无环路路径很可能比较短的无环路路径更可取。例如，AS可能更愿意将流量发送给一个邻居，而不是另一个距离较短的邻居。

P14、

a) eBGP 

b) iBGP 

c) eBGP 

d) iBGP 


P15、

a）I1，因为这个接口开始从1D到网关路由器1c的最低成本路径。

(B)I2。这两种路由都有相等的路径长度，但I2开始的路径有最近的下一跳路由器。

(C)一.1。I1开始具有最短路径的路径。

P16、C迫使B在东海岸将所有B的流量移交给D的方法之一是C只在东海岸通过其东海岸凝视点登出其到D的路线。

P17、

![avater](./img/8.png)

在上述解决方案中，X不知道AC链路，因为X没有接收到包含AC链路的w或y的广告路由(即，X在到达目的地的路径上没有接收包含A和AS C的广告。

P18、BitTorrent文件共享和Skype P2P应用程序。考虑一个BitTorrent文件共享网络，其中对等点1、2和3分别位于存根网络W、X和Y中。由于BitTorrent的文件共享机制，使得Peer 2有可能从Peer 1中获取数据块，然后将这些数据块转发到3，这相当于最终被发送到存根网络Y的B转发数据。

P19、A应该建议B两条路线，A-W和A-V。

A应该只向C建议一条路线，A-V。

C作为路径接收：B-A-W、B-A-V、A-V。

P20、由于Z想要传输Y的流量，Z将以这种方式向Y发送路由广告。这样，当Y有一个发送到可以通过Z到达的IP的数据报时，Y将可以选择通过Z发送该数据报。但是，如果Z将路由转发到Y，Y可以将这些路由重登到X。因此，在这种情况下，Z无法阻止从X到Z的传输。

P21、请求响应模式通常会有更多的开销(以交换消息的数量来衡量)，原因有几个。首先，经理收到的每一条信息都需要两条消息：投票和响应。陷阱只向发送方生成一条消息。如果管理器只希望在发生条件时才得到通知，那么轮询的开销就会更大，因为许多轮询消息可能表明等待条件尚未发生。陷阱只在条件发生时生成消息。

在发生事件时，陷阱还会立即通知经理。使用轮询，管理器需要等待半个轮询周期(平均)，从事件发生到经理(通过其轮询消息)发现事件已经发生。

如果丢失了陷阱消息，托管设备将不会发送其他副本。如果一个投票消息或它的响应丢失了，经理就会知道已经丢失了一条消息(因为答复永远不会到达)。因此，如果需要，经理可以重新投票。

P22、通常，最需要网络管理的时间是在压力时，网络可能会严重拥挤，数据包正在丢失。在TCP上运行SNMP时，TCP的拥塞控制将导致SNMP在网络管理器需要发送SNMP消息时退出并停止发送消息。

# 第六章

## 复习题6 

R1、交通方式，如汽车、公共汽车、火车、汽车。

R2、虽然每个链路保证通过链路发送的IP数据报将在链路的另一端无错误地被接收，但不能保证IP数据报将以适当的顺序到达最终目的地。使用IP，同一TCP连接中的数据报可以在网络中采取不同的路由，从而导致出现故障。仍然需要TCP以正确的顺序向应用程序的接收端提供字节流。此外，IP可能由于路由循环或设备故障而丢失数据包。

R3、帧：IP和TCP中也有帧；链路访问；可靠传递：TCP中也有可靠的传递；流控制：TCP中也有流控制；错误检测：IP和TCP中也有错误检测；错误更正；全双工：TCP也是全双工。

R4、当一个节点正在发送时，它将开始从另一个节点接收一个分组，这将发生冲突。

R5、时隙ALOHA：1、2和4(时隙ALOHA仅部分分散，因为它要求所有节点中的时钟是同步的)。令牌环：1，2，3，4。

R6、在第5次碰撞之后，适配器从{0，1，2，…中选择，31。它选择4的概率是1/32。等待204.8微秒。

R7、在民意测验中，讨论领袖一次只允许一个参与者说话，每个参与者都有机会以一种循环的方式交谈。对于象征性的戒指，没有讨论的领导者，但有葡萄酒杯，参与者轮流持有。只有当参与者拿着酒杯时，才允许参与者说话。

R8、当节点发送帧时，节点必须等待帧在整个环周围传播，然后节点才能释放令牌。因此，如果L/R比tprop小，那么协议就会效率低下。

R9、$2^{48}$个MAC地址；$2^{32}$个IPv4地址；$2^{128}$个IPv6地址。

R10、C的适配器将处理这些帧，但是适配器不会将数据报传递到协议栈中。如果使用LAN广播地址，则C的适配器将处理帧并将数据报传递到协议栈。

R11、在广播帧中发送ARP查询，因为查询主机没有将哪个适配器地址对应于所述IP地址。对于响应，发送节点知道应该将响应发送到的适配器地址，因此不需要发送广播帧(必须由LAN上的所有其他节点处理)。

R12、不可能。每个LAN都有自己的一组不同的适配器，每个适配器都有一个唯一的LAN地址。

R13、这三种以太网技术具有相同的帧结构。

R14、2(内部子网和外部因特网)

R15、在802.1Q中有一个12位的VLAN标识符。因此，可以支持212=4096个VLAN。

R16、我们可以把N个开关串在一起。第一个也是最后一个交换机将使用一个端口进行中继；中间的N-2交换机将使用两个端口。因此，端口总数为2+2(N-2)=2N-2端口。

## 问题6 

P1、

1 1 1 0 1 

0 1 1 0 0 

1 0 0 1 0 

1 1 0 1 1 

1 1 0 0 0 

P2、假设我们从初始的二维奇偶矩阵开始：

0 0 0 0 

1 1 1 1 

0 1 0 1 

1 0 1 0 

由于在第2行第3栏中出现了一些错误，第2行和第3列的奇偶校验现在在下面的矩阵中是错误的：

0 0 0 0 

1 1 0 1 

0 1 0 1 

1 0 1 0 

现在假设第2行、第2列和第3列有一个位错误。第2行的奇偶校验现在是正确的！列2和3的奇偶校验是错误的，但是我们不能检测错误发生在哪一行！

0 0 0 0

1 0 0 1 

0 1 0 1 

1 0 1 0 

上述示例显示，可以检测到双比特错误(如果没有纠正)。

P3、
```
  01001100 01101001 
+ 01101110 01101011 
------------------------------ 
  10111010 11010100 
+ 00100000 01001100 
------------------------------ 
  11011011 00100000 
+ 01100001 01111001
----------------------------- 
  00111100 10011010 (溢出，然后绕过去) 
+ 01100101 01110010 
------------------------------ 
  10100010 00001100 
```
和的补码是： 01011101 11110011 

P4、

a) 要计算网络检验值，我们将16位量的值加起来： 
```
 00000001 00000010 
 00000011 00000100 
 00000101 00000110 
 00000111 00001000 
 00001001 00001010 
 ------------------------- 
 00011001 00011110 
```
和补码为：11100110 11100001. 
b) 要计算网络检验值，我们将16位量的值加起来： 
```
01000010 01000011 
01000100 01000101 
01000110 01000111 
01001000 01001001 
01001010 01001011 
------------------------- 
10011111 10100100 
```
和补码为：01100000 01011011 

c) 要计算网络检验值，我们将16位量的值加起来
```
01100010 01100011 
01100100 01100101 
01100110 01100111 
01101000 01101001 
01101010 01101011 
------------------------- 
00000000 00000101 
```
和补码为：11111111 11111010.


P5、如果我们将10011分为1010101010 0000，我们可以得到1011011100，剩余R=0100。注意G=10011是CRC-4-ITU标准。 

P6、

a)我们得到1000110000，剩余R=0000。

b)我们得到0101010101，剩余R=1111. 

c)我们得到1011010111，剩余R=1001. 


P7、

(A)在不失去通用性的情况下，假设ith位被翻转，其中0<= i <= d+r-1 并假设最不重要的位是第0位。单比特错误意味着接收到的数据为K=D*2R XOR R2 i。很明显，如果我们把K除以G，那么提醒不是零。通常情况下，如果G包含至少两个1，则总是可以检测到单个比特错误。

(B)这里的关键洞见是G可以被11(二进制数)除以，但任何奇数的1‘s不能除以11。因此，奇数位错误的序列(不一定是连续的)不能除以11，因此不能被G除以G。

P8、

a)

$E(p)=NP(1-p)^{N-1}$

$E'(p)=N(1-p)^{N-1}-Np(N-1)(1-p)^{N-2}=N(1-p)^{N-2}((1-p)-p(N-1))$

b) 

$E(p^\ast )=N\frac{1}{N}(1-\frac{1}{N})^{N-1}=(1-\frac{1}{N})^{N-1}=\frac{(1-\frac{1}{N})^N}{1-\frac{1}{N}}$

$\lim_{N \to \infty }(1-\frac{1}{N})=1$

$\lim_{N \to \infty }(1-\frac{1}{N})^N=\frac{1}{e}$

因此

$\lim_{N \to \infty }E(p^\ast )=\frac{1}{e}$

P9、

$E(p)=NP(1-p)^{2(N-1)}$

$E'(p)=N(1-p)^{2(N-1)}-Np2(N-1)(1-p)^{2(N-3)}=N(1-p)^{2(N-3)}((1-p)-p2(N-1))$

$E'(p)=0\Rightarrow p^*=\frac{1}{2N-1}$

$E(p^*)=\frac{N}{2N-1}(1-\frac{1}{2N-1})^{2(N-1)}$

$\lim_{N \to \infty }E(p^*)=\frac{1}{2}\cdot \frac{1}{e}=\frac{1}{2e}$

P10、
a)A的平均吞吐量由Pa(1-PB)给出.总效率为Pa(1-PB)PB(1-Pa).

(B)A的吞吐量为Pa(1-PB)=2PB(1-PB)=2PB-2(PB)2，B的吞吐量为PB(1-Pa)=PB(1-2PB)=PB-2(PB)2，很明显，A的吞吐量不是B的两倍，为了使PA(1-PB)=2PB(1-Pa)，我们需要PA=2-(Pa/PB)。

(C)A的吞吐量为2p(1-p)N1，任何其他节点的吞吐量p(1-p)N-2(1-2p)。

P11、

a) (1 – p(A))4 p(A) 

其中p(A) = A在一个槽中成功的概率 

 p(A) = p(A传输并且B不传输并且C不传输并且D不传输) = p(A传输) p(B不传输) p(C不传输) p(D不传输) = p(1 – p) (1 – p)(1-p) = p(1 – p)3 

因此， p(A第一次在5号槽成功) = (1 – p(A))4 p(A) = (1 – p(1 – p)3)4 p(1 – p)3 

b) p(A在4槽中成功) = p(1-p)3 

p(B在4槽中成功) = p(1-p)3 

p(C在4槽中成功) = p(1-p)3 

p(D在4槽中成功) = p(1-p)3 

p(要么A或者B或者C或者D在4号槽中成功) = 4 p(1-p)3 (因为这些事件是相互排斥的) 

c) p(一些结点在一个槽中成功) = 4 p(1-p)3 

p(一个槽中没有结点成功) = 1 - 4 p(1-p)3

因此，p(第一个成功发生在3槽) = p(没有结点在前2个槽中成功) p(一些结点在第三个槽中成功) = (1 - 4 p(1-p)3)2 4 p(1-p)3 

d) 效率 = p(在一个槽中成功) =4 p(1-p)3 


P12、

![avater](./img/7.png)

![avater](./img/6.png)

P13、轮询轮的长度为：

$N(Q/R+d_{poll})$

在轮询轮中传输的比特数是NQ。因此，最大吞吐量是:

$\frac{NQ}{N(Q/R+d_{poll})}=\frac{R}{1+\frac{d_{poll}R}{Q}}$

P14、a）b）见下图：

![avater](./img/5.png)

c）
1.E中的转发表确定数据报应路由到接口192.168.3.002。

2.E中的适配器创建具有以太网目的地地址88-88-88-88-88-88-88的以太网数据包。

3.路由器2接收数据包并提取数据报。此路由器中的转发表指示数据报将被路由到198.162.2.002。

4.路由器2然后通过其与IP地址198.162.003的接口发送目的地址为33-33-33-33-33-33-33-33和源地址为55-55-55-55-55-55-55-55-55-55的以太网分组。

5.这一过程一直持续到数据包到达主机B为止。

(D)E中的ARP现在必须确定198.162.3.002的MAC地址。主机E在广播以太网帧内发送ARP查询包。路由器2接收查询包并向主机E发送ARP响应包。此ARP响应包由以太网帧承载，以太网目的地地址为77-77-77-77-77-77-77-77。

P15、(A)否。E可以检查主机F的IP地址的子网前缀，然后了解F在同一个局域网上。因此，E不会将数据包发送到默认路由器R1。

从E到F的以太网帧：

源IP=E的IP地址

目的地IP=F的IP地址

源MAC=E的MAC地址

目的地MAC=F的MAC地址

b)不，因为它们不在同一个局域网上。E可以通过检查B的IP地址来发现这一点。

从E到R1的以太网帧：

源IP=E的IP地址

目的地IP=B的IP地址

源MAC=E的MAC地址

目的地MAC=连接到子网的R1接口的MAC地址。

c)交换机S1将通过两个接口广播以太网帧，因为接收到的ARP帧的目的地地址是广播地址。它了解到A驻留在连接到子网1的子网1上，并且S1将更新它的转发表以包括主机A的条目。

是的，路由器R1也接收这个ARP请求消息，但是R1不会将消息转发到子网3。

B不会发送请求A的MAC地址的ARP查询消息，因为这个地址可以从A的查询消息中获得。

一旦交换机S1接收到B的响应消息，它将在其转发表中为主机B添加一个条目，然后删除接收到的帧，因为目的地主机A与主机B在同一个接口上(即A和B位于同一个LAN段上)。

P16、让我们称子网2和3s2之间的切换为S2。也就是说，子网2和3之间的路由器R1现在被交换机S2所取代。

(A)否。E可以检查主机F的IP地址的子网前缀，然后了解F在同一个LAN段上。因此，E不会将数据包发送到S2。

从E到F的以太网帧：

源IP=E的IP地址

目的地IP=F的IP地址

源MAC=E的MAC地址

目的地MAC=F的MAC地址

b）是的，因为E想找到B的MAC地址。在这种情况下，E将发送一个ARP查询包，目标MAC地址是广播地址。

该查询包将由交换机1重新广播，最终由主机B。

以太网帧从E接收到S2：

源IP=E的IP地址

目的地IP=B的IP地址

源MAC=E的MAC地址

目的地MAC=广播MAC地址：FF-FF-FF-FF-FF-FF。

(C)交换机S1将通过两个接口广播以太网帧，因为接收到的ARP帧的目标地址是广播地址。它了解到A驻留在连接到子网1的子网1上，并且S1将更新它的转发表以包括主机A的条目。

是的，路由器S2也接收这个ARP请求消息，S2将这个查询包广播到它的所有接口。

B不会发送请求A的MAC地址的ARP查询消息，因为这个地址可以从A的查询消息中获得。

一旦交换机S1接收到B的响应消息，它将在其转发表中为主机B添加一个条目，然后删除接收到的帧，因为目的地主机A与主机B在同一个接口上(即A和B位于同一个LAN段上)。

P17、等待51200比特时间。对于10 Mbps，这个等待是

$\frac{51.2\times 10^3 bits}{10\times 10^6 bps}=5.12ms$

对于100Mbps，等待时间是512$\mu s$

P18、在t=0时A发射。在t=576时，A将完成传输。在最坏的情况下，B在时间t=324开始发送，即A的第一个帧到达B之前的时间。在时间t=324+325=649时 B的第一个比特到达A时，A在检测到B已经发送之前就完成了传输，所以A错误地认为它的帧在没有碰撞的情况下被成功地传输了。

P19、

|时间，t|事件|
|------|---|
|0|A和B开始传输|
|245|A和B检测碰撞|
|293|A和B结束拥塞信号传输|
|293+245=538|B的最后一比特到达A；A检测空闲线路|
|538+96=634|A开始传输|
|293+512=805|B返回到第二步|
||B必须对空闲信道进行96 bit的检测，然后才能传输。|
|634+245=879|A的传送到达B|

由于A的重传在B的预定重传时间(805+96)之前到达B，所以B在A重传时不进行传输，因此A和B不发生碰撞，因此指数退避算法中出现的因子512足够大。

P20、

a）设Y是表示插槽数目的随机变量，直到成功：

$P\left ( Y=m \right )=\beta \left ( 1-\beta \right )^{m-1}$

$\beta$表示成功的概率。

这是一个几何分布，它的平均值为$1/\beta$。连续浪费的插槽数为X=Y-1 其中

$x=E[X]=E[Y]-1=\frac{1-\beta}{\beta}$

$\beta = Np\left ( 1-p \right )^{N-1}$

$x=\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}=\frac{k}{k+x}=\frac{k}{k+\frac{1-Np(1-p)^{N-1}}{Np(1-p)^{N-1}}}$

效率

b）最大化效率等同于最小化x，这相当于最大化$\beta$。我们从文本中得知，$\beta$在$p=\frac{1}{N}$处是最大的。

c）效率=$\frac{k}{k+\frac{1-(1-\frac{1}{N})^{N-1}}{(1-\frac{1}{N})^{N-1}}}$

$\lim_{N \to\infty } efficiency =\frac{k}{k+\frac{1-1/e}{1/e}}=\frac{k}{k+e-1}$

d）显然，当k趋近于无穷时$\frac{k}{k+e-1}$趋近于1。

P21、

![avater](./img/4.png)

i) 从A到右路由器：

   源MAC地址：00-00-00-00-00-00 

   目的地MAC地址：22-22-22-22-22-22 

   源IP：111.111.111.001 

   目的地IP：133.333.333.003 

ii) 从交换机到右路由器：

   源MAC地址：33-33-33-33-33-33

   目的地MAC地址: 55-55-55-55-55-55 

   源IP: 111.111.111.001 

   目的地IP: 133.333.333.003 

iii) 从右路由器到F：

   源MAC地址: 88-88-88-88-88-88 

   目的地MAC地址: 99-99-99-99-99-99 

   源IP: 111.111.111.001 

   目的地IP: 133.333.333.003


P22、
i) 从A到交换机：

   源MAC地址：00-00-00-00-00-00 

   目的地MAC地址：55-55-55-55-55-55 

   源IP：111.111.111.001 

   目的地IP：133.333.333.003 

ii) 从交换机到右路由器：

   源MAC地址：00-00-00-00-00-00

   目的地MAC地址: 55-55-55-55-55-55 

   源IP: 111.111.111.001 

   目的地IP: 133.333.333.003 

iii) 从右路由器到F：

   源MAC地址: 88-88-88-88-88-88 

   目的地MAC地址: 99-99-99-99-99-99 

   源IP: 111.111.111.001 

   目的地IP: 133.333.333.003 


P23、如果所有11=9.2节点以100 Mbps的最大可能速率发送数据，则总总吞吐量为11*100=1100 Mbps是可能的。

P24、每个部门中心都是一个冲突域，最大吞吐量为100 Mbps。连接Web服务器和邮件服务器的链接的最大吞吐量为100 Mbps。因此，如果三个碰撞域以及Web服务器和邮件服务器以各自100 Mbps的最大可能速率发送数据，则11端系统之间的总总吞吐量可达到500 Mbps。

P25、所有的11端系统都将处于相同的碰撞域。在这种情况下，在11端系统中，最大总吞吐量为100 Mbps是可能的。

P26、

|行为|开关表状态|链路包前往|解释|
|---|---------|--------|---|
|B发送一帧给E|与B的MAC地址对应的交换机学习接口|A,C,D,E,F|由于交换机表是空的，所以交换机不知道与E的MAC地址对应的接口|
|E发送一帧给B|与E的MAC地址对应的交换机学习接口|B|由于交换机已经知道与B的MAC地址对应的接口|
|A发送一帧给B|与A的MAC地址对应的交换机学习接口|B|由于交换机已经知道与B的MAC地址对应的接口|
|B发送一帧给A|切换表状态与以前相同。|A|由于交换机已经知道与A的MAC地址对应的接口|

P27、

a）填充$L\cdot8$ bits需要的时间是：

$\frac{L\cdot8}{128\times 10^3 } sec = \frac{L}{16}ms$

b）对于L=1500，包化延迟为：

$\frac{1500}{16}ms=93.75 ms$

对于L=50，包化延迟为：

$\frac{50}{16}ms=3.125 ms$

c）存储和转发延迟为$\frac{L \cdot 8+40}{R}$

对于L=1500，延迟为

$\frac{1500\cdot 8+40}{622\times 10^{6}} sec \approx 19.4 \mu s$

对于L=50，存储和转发延迟<1微秒。

d）对于典型的链路速度，存储和转发延迟对于这两种情况都是很小的.然而，L=1500的分组化延迟对于实时语音应用来说太大了.

P28、EE部门这三台计算机(从左到右)的IP地址是：111.111.1.1、111.111.1.2、111.111.1.3。子网掩码为111.111.1/24。

CS部门这三台计算机(从左到右)的IP地址是：111.111.2.1、111.111.2.2、111.111.2.3。子网掩码为111.111.2/24。

连接到端口1的路由器接口卡可以配置为包含两个子接口IP地址：111.111.1.0和111.111.2.0。第一种是针对EE部门的子网，第二种是针对CS部门的子网。每个IP地址都与VLAN ID相关联。假设111.111.1.0与VLAN 11相关联，111.111.2.0与VLAN 12相关联。这意味着来自子网111.111.1/24的每一帧将被添加一个带有VLAN ID 11的802.1q标记，而来自111.111.2/24的每一帧将被添加一个带有VLAN ID 12的802.1q标记。

假设EE部门中具有IP地址111.111.1.1的主机A希望向CS部门中的主机B(111.111.2.1)发送IP数据报。主机A首先将IP数据报(目的地为111.111.2.1)封装到具有与连接到交换机端口1的路由器接口卡的MAC地址相等的目标MAC地址的帧中。一旦路由器接收到该帧，然后将其传递到IP层，该层决定通过子接口111.111.2.0将IP数据报转发到子网111.111.2/24。然后路由器将IP数据报封装成一个帧并发送到端口1。请注意，该帧有一个802.1q标记VLAN ID 12。一旦交换机接收到帧端口1，它就知道该帧被发送到ID为12的VLAN，因此交换机将该帧发送到位于CS部门的主机B。一旦主机B接收到此帧，它将删除802.1q标记。

P29、

![avater](./img/3.png)

P30、

![avater](./img/2.png)

P31、(下面的说明很简短，但包含了所有主要的关键步骤和涉及的关键协议。)

您的计算机首先使用DHCP获取IP地址。您的计算机首先在DHCP服务器发现步骤中创建一个指定为255.255.255.255的特殊IP数据报，并将其放在以太网帧中并在以太网中广播。然后，按照DHCP协议中的步骤，您的计算机能够获得具有给定租约时间的IP地址。

以太网上的DHCP服务器还为计算机提供了第一跳路由器的IP地址列表、计算机所在子网的子网掩码以及本地DNS服务器的地址(如果存在的话)。

由于您的计算机的ARP缓存最初是空的，您的计算机将使用ARP协议来获取第一跳路由器和本地DNS服务器的MAC地址。

您的计算机将首先获得您想要下载的网页的IP地址。如果本地DNS服务器没有IP地址，则计算机将使用DNS协议查找网页的IP地址。

一旦计算机拥有了网页的IP地址，如果网页不驻留在本地Web服务器中，它将通过第一跳路由器发送HTTP请求。HTTP请求消息将被分割并封装到TCP数据包中，然后进一步封装到IP数据包中，最后封装到以太网帧中。您的计算机将以太网帧发送到第一跳路由器.一旦路由器接收到这些帧，就会将它们传递到IP层，检查其路由表，然后将数据包从所有接口发送到正确的接口。

然后，您的IP包将通过互联网路由，直到它们到达Web服务器。

承载网页的服务器将通过HTTP响应消息将网页发送回计算机。这些消息将被封装到TCP数据包中，然后进一步封装到IP数据包中。这些IP数据包遵循IP路由，最终到达第一跳路由器，然后路由器将这些IP数据包封装到以太网帧中，将它们转发到计算机上。

P32、

A)每个流均匀分布一个链路的容量，然后80个流通过B到接入路由器10Gbps链路（以及接入路由器到边界路由器链路），每个都将仅接收10Gbps/80=125Mbps

b)在图5.31的拓扑中，第一层和第三层2交换机之间有四个不同的路径，一起为从机架14到机架912的流量提供40Gbps。类似地，第二层和第四层2交换机之间有四个链路，一起为来自机架58到1316的业务提供40Gbps。因此，总的总带宽是80Gbps，并且每个流速的值是1Gbps。

c)现在20个流量需要在TOR交换机对之间共享每1Gbps带宽。因此，主机到主机的比特率将为0.5Gbps。

P33、

a）电子邮件和视频应用程序使用第四个机架占时间的0.1%。

b）两个应用需要第四机架的概率为0.001*0.001=10-6.

c）假设前三个机架是用于视频的，下一个机架是用于两个机架的共享机架视频和电子邮件，接下来的三个机架用于电子邮件。我们假设第四个机架拥有电子邮件和视频应用程序所需的所有数据和软件。使用图5.31的拓扑，两个应用程序都具有足够的带宽内带宽只要两者都不同时使用第四机架。从B部分，均为：使用第四个机架不超过.00001%的时间，该时间在.0001%以内要求。

# 第七章

## 复习题7 

1、在基础设施模式的操作，每一个无线主机都通过一个基站（接入点）连接到更大的网络。如果不是在基础模式操作，网络以ad-hoc模式操作。在ad-hoc模式下，无线主机没有可连接的基础设施。在缺少基础设施的情况下，主机必须自己提供如路由器、地址分配、DNS类似名称翻译和更多的服务。

2、a）单点，基于设备

b）单点，缺少设备

c）多点，基于设备

d）多点，缺少设备

3、路径损耗是由于电磁信号在物质中传播时的衰减所致。多径传播导致接收端接收信号模糊，当电磁波部分反射物体和地面时，在发送者和接收者之间选择不同长度的路径时发生。当另一个源也在与无线网络相同的频率范围内发送时，来自其他源的干扰发生。

4、

a）增加传输功率

b）降低传输率

5、AP发射信标帧。AP的信标帧将通过11个信道中的一个进行传输。信标帧允许附近的无线站发现和识别AP。

6、假

7、AP发射信标帧。AP的信标帧将通过11个信道中的一个进行传输。信标帧允许附近的无线站发现和识别AP。

8、假

9、每个无线站可以设置RTS阈值，使RTS/CTS序列仅在要发送的数据帧大于阈值时使用。这确保RTS/CTS机制仅用于大帧。

10、不，不会有什么好处的。假设有两个站同时发送，它们都使用RTS/CTS。如果RTS帧与数据帧一样长，则只要信道被浪费在两个冲突的数据帧上，信道就会被浪费。因此，只有当RTS/CTS帧明显小于数据帧时，RTS/CTS交换才是有用的。

11、最初，交换机在其转发表中有一个条目，该条目将无线站与较早的AP相关联。当无线站与新AP相关联时，新AP创建具有无线电台MAC地址的帧并广播该帧。该帧由交换机接收。这迫使交换机更新其转发表，以便通过新的AP发送发送到无线站的帧。

12、任何普通的蓝牙节点都可以是主节点，而802.11网络中的接入点是特殊的设备(普通的无线设备，如膝上型计算机，不能用作接入点)。

13、假

14、“机会主义调度”是指将物理层协议与发送方和接收方之间的信道条件相匹配，并根据信道条件选择要发送数据包的接收方。这使得基站能够充分利用无线媒体。

15、UMTS对于GSM和CDMA-2000对与IS-95.

16、eNodeB的数据平面作用是在UE(通过LTE无线接入网)和P-GW之间转发数据报。它的控制平面作用是代表UE处理注册和移动信令业务。

移动管理实体(MME)代表驻留在其控制单元中的ue执行连接和移动管理。它从HHS接收UE订阅信息。

分组数据网络网关(P-GW)将IP地址分配给UE并执行QoS强制执行。作为隧道端点，它还在向UE转发数据报时执行数据报封装/解封装。

服务网关(S-GW)是数据平面移动锚点，因为所有UE业务都将通过S-GW.S-GW还执行收费/计费功能和合法的流量拦截。

17、在3G体系结构中，话音和数据有独立的网络组件和路径，即话音通过公用电话网络，而数据通过公共互联网。4G体系结构是一个统一的全IP网络体系结构，即语音和数据在IP数据报中传送到或从无线设备传送到多个网关，然后传送到因特网的其他部分。

4G网络体系结构将数据和控制平面清晰地分开，这与3G体系结构不同。

4G架构有一个增强的无线接入网(E-UTRAN)，它不同于3G的无线接入网UTRAN。

18、没有。在连接到Internet的整个过程中，节点可以保持与同一接入点的连接(因此，不能移动)。移动节点是随着时间的推移将其连接点转换为网络的节点。由于用户总是通过同一个接入点访问Internet，所以她不能移动。

19、移动节点的永久地址是其在家庭网络中的IP地址。地址的关心是它在访问外国网络时得到的地址.COA由外部代理(可以是外部网络中的边缘路由器或移动节点本身)分配。

20、假

21、GSM中的家庭网络维护一个称为归属位置寄存器的数据库(HLR)，其包含永久单元电话号码和用户简档关于其每个用户的信息。HLR还包含关于这些用户的当前位置。被访问的网络维护一个数据库称为访问位置寄存器(VLR)，其包含每个移动台的条目当前位于由VLR服务的网络部分中的用户。VLR条目因此，当移动用户进入并离开网络时，进入并进入。

移动IP中归属网络中的边缘路由器与GSM中的HLR和GSM中的HLR类似,国外网络中的边缘路由器与GSM中的VLR类似。

22、锚MSC是在第一次呼叫开始时由移动访问的MSC；因此，锚MSC在呼叫期间保持不变。在整个呼叫持续时间内，无论由移动执行的MSC间传输的次数如何，呼叫都是从家乡MSC路由到锚MSC，然后从锚MSC路由到当前移动位置所在的已访问MSC。

23、

a）本地恢复

b）TCP发送方对无线链路的感知

c）拆分连接方法

## 问题7 

P1、
位d1对应的输出 = [-1,1,-1,1,-1,1,-1,1]

位d0对应的输出= [1,-1,1,-1,1,-1,1,-1] 

P2、
发送方2输出为：

   [1,-1,1,1,1,-1,1,1]
   [1,-1,1,1,1,-1,1,1] 

P3、

$d_{2}^{1}=\frac{1 \times 1+(-1)\times(-1)+1 \times 1+1 \times 1+1 \times 1+(-1)\times(-1)+1\times1+1\times1}{8}=1$

$d_{2}^{2}=\frac{1 \times 1+(-1)\times(-1)+1 \times 1+1 \times 1+1 \times 1+(-1)\times(-1)+1\times1+1\times1}{8}=1$


P4、
   发送方 1: (1, 1, 1, -1, 1, -1, -1, -1) 

   发送方 2: (1, -1, 1, 1, 1, 1, 1, 1) 


P5、a）两个AP通常具有不同的SSID和MAC地址。无线到达CAFTA的站将与其中一个SSID（即，其中一个AP）相关联。在关联之后，在新站点和AP之间存在虚拟链路。标记AP1和AP2。假设新站点与AP1相关联。当新的站发送帧，它将被寻址到AP1。尽管AP2还将接收帧，因为帧未被寻址，所以它将不处理帧。是的。因此，两个ISP可以在同一信道上并行工作。然而,这两个ISP将共享相同的无线带宽。如果不同的无线站不同ISP同时发送，会发生冲突。对于802.11b，最大值两个ISP的聚合传输速率为11Mbps。

b）现在，如果不同ISP（以及因此不同的信道）中的两个无线站发送同时，不会发生碰撞。因此,最大骨料对于802.11b，两个ISP的传输速率为22Mbps。

P6、假设无线站h1有1000个长帧要发送。(h1可能是将MP3转发到其他无线电台的AP。)假设最初h1是唯一想要传输的站，但是在传输其第一个帧的中途，h2想发送一个帧。为了简单起见，也假设每个站都能听到其他站的信号(也就是说，没有隐藏的终端)。在传输之前，H2将感觉到信道是繁忙的，因此选择一个随机的退避值。

现在假设在发送第一个帧之后，h1返回到步骤1；也就是说，它等待一个短时间(DIFS)，然后开始发送第二个帧。h1的第二帧将被传输，而h2被卡在退避中，等待空闲信道。因此，h1应该能够在h2有机会访问信道之前传输其所有1000帧。另一方面，如果h1在发送帧后进入步骤2，那么它也会选择一个随机的退避值，从而给h2一个公平的机会。因此，公平是这种设计选择的理由。

P7、没有数据的帧有32个字节长。假设传输速率为11 Mbps，发送控制帧(例如RTS帧、CTS帧或ACK帧)的时间为(256 bits)/(11 Mbps)=23 USEC。传输数据帧所需的时间为(8256 bits)/(11 Mbps)=751

P8、a) 1 message/ 2 slots 

b) 2 messages/slot 

c) 1 message/slot 

d)
   i) 1 message/slot 

   ii) 2 messages/slot 

   iii) 2 messages/slot 

e) 

   i) 1 message/4 slots 

   ii)

   slot 1: Message A→ B, message D→ C 

   slot 2: Ack B→ A 

   slot 3: Ack C→ D 

   = 2 messages/ 3 slots 

iii) 

   slot 1: Message C→ D 

   slot 2: Ack D→C, message A→ B 

   slot 3: Ack B→ A 

   = 2 messages/3 slots

P10、a）如果只向节点A发送10 Mbps，则此解决方案不公平，因为只有A正在得到服务。所谓“公平”，意味着四个节点中的每一个都应该分配相同数量的插槽。

(B)对于公平性要求，使每个节点在每个下游子帧期间接收相等数量的数据，让n1、n2、n3和n4分别表示A、B、C和D所得到的时隙数。

现在，在1时隙中发送给A的数据=10 tMbit(假设每个时隙的持续时间为t)，

因此，发送给A(在N1时隙中)的总数据量=10tN1，

同样地，发送给B、C和D的数据总量分别等于5tN2、2.5tn3和tN4。

现在，为了满足既定的公平要求，我们有以下条件：

10t n1 = 5t n2 = 2.5t n3 = t n4 

因此 
   n2 = 2 n1 

   n3 = 4 n1 

   n4 = 10 n1 

现在， 槽的总数是N。因此， 

   n1+ n2+ n3+ n4 = N 

   i.e. n1+ 2 n1 + 4 n1 + 10 n1 = N 

   i.e. n1 = N/17 

因此， 
   n2 = 2N/17 

   n3 = 4N/17 

   n4 = 10N/17 

平均传输速率为： 
   (10t n1+5t n2+ 2.5t n3+t n4)/tN 

   = (10N/17 + 5 * 2N/17 + 2.5 * 4N/17 + 1 * 10N/17)/N 

   = 40/17 = 2.35 Mbps 

c）在子帧中，节点A接收的数据是节点B、C和D的两倍。因此，

 10tn1 = 2 * 5tn2 = 2 * 2.5tn3 = 2 * tn4 

 i.e. n2 = n1 

 n3 = 2n1 

 n4 = 5n1 

同样的， 

 n1 + n2 + n3 + n4 = N 

 i.e. n 1+ n1 + 2n1 + 5n1 = N 

 i.e. n1 = N/9 

平均传输速率是： 

 (10t n1+5t n2+ 2.5t n3+t n4)/tN 

 = 25/9 = 2.78 Mbps 

同样，考虑节点B、C或D接收的数据是任何其他节点的两倍，可以计算平均传输速率的不同值。

P11、（A）否。所有路由器可能无法立即路由数据报。这是因为距离向量算法（以及AS之间的路由协议，如是分散的，需要一些时间来终止。所以，在这段时间算法仍在运行，因为广告来自新的外国网络，一些路由器可能无法将数据报路由到移动节点。
（B）是。当其中一个节点刚刚离开一个外国网络时可能会发生这种情况加入了一个新的外国网络。在这种情况下，从旧的路由条目外国网络可能没有完全撤回时，从新的网络正在被传播。
（C）路由器学习移动节点路径所需的时间取决于的路由器和边缘路由器之间的跳数节点。

P12、

![avater](./img/1.png)

如果通讯员是可移动的，那么发送给记者的任何数据报都必须通过通讯员的家庭代理。访问的网络中的外国代理也需要参与，因为正是该外国代理将通讯员的位置通知通讯员的本国代理。记者的本地代理接收到的数据报需要在通讯员的本地代理和外部代理之间封装/隧道化(如图6.23顶部的封装图所示)。

P13、因为数据报必须首先转发给归属代理，并且从那里转发到移动设备，所以延迟通常将比通过直接路由更长。但是，可能的是，从通信方到移动设备的直接延迟(即，如果数据报没有通过归属代理路由)实际上可以小于从通信方到归属代理和从那里到移动设备的延迟的总和。这取决于这些不同路径段的延迟。注意，间接路由还增加了归属代理处理(例如，封装)延迟。

P14、首先，我们注意到在第6.5节末尾讨论了链接。在使用通过归属代理的间接路由进行链接的情况下，将发生以下事件：
- 移动节点到达A，A通知归属代理移动正在访问A，移动到移动端的数据报现在应该被转发到A中指定的注意地址(COA)。
- 移动节点移动到B。B处的外国代理必须通知A处的外国代理，该移动设备已不在A中，但实际上是在B中，并且在B中有指定的COA。从那时起，A中的外国代理将接收到的数据报发送到A中的移动COA到B中的移动COA。
- 移动节点移动到C。C处的外国代理必须通知B处的外国代理，该移动设备已不在B中，但实际上是C中的C，并且在C中具有指定的COA。从那时起，B中的外国代理将它收到的(从A中的外国代理接收的)发送到移动台B中的COA的数据报转发到移动的C中的COA。

请注意，当移动设备离线(即，没有地址)或返回到其家乡网络时，必须删除由A、B和C中的外国代理维护的数据报转发状态。这种拆卸也必须通过信令消息来完成。请注意，本地代理不知道移动设备的移动性超过A，并且通讯员根本不知道移动设备的移动性。

在不使用链接的情况下，将发生以下事件：
- 移动节点到达A，A通知归属代理移动正在访问A，移动到移动端的数据报现在应该被转发到A中指定的注意地址(COA)。
- 移动节点移动到B。B处的外国代理必须通知A处的外国代理和本地代理，移动台已不再是A中的居民，但实际上是在B中，并且在B中有指定的COA。A中的外国代理可以移除其关于移动的状态，因为它不再在A中，因此本地代理将转发它在B中收到的发送到移动的COA的数据报。
- 移动节点移动到C。C处的外国代理必须通知B处的外国代理和本地代理，移动台已不再是B中的居民，但实际上是C中的C，并且在C中有指定的COA。B中的外国代理可以移除其关于移动的状态，因为它不再在B中。从那时起，本地代理将转发它在C中收到的发送到移动的COA的数据报。

当移动设备离线或返回其家庭网络时，必须移除外国代理在C中维护的数据报转发状态。这种拆卸也必须通过信令消息来完成。请注意，本地代理总是知道移动当前的外部网络。然而，记者仍然幸灾乐祸地不知道手机的移动性。

P15、在同一个访问网络中，两个移动电话的地址肯定是相同的。事实上，如果地址是外国代理人的地址，那么这个地址也是一样的.一旦外国代理解封装隧道数据报并确定移动地址，则需要使用单独的地址将数据报分别发送到访问网络中的不同目的地(手机)。

P16、如果向HLR提供了MSRN，则当MSRN发生变化时(例如，当切换要求MSRN改变时)，必须在HLR中更新MSRN的值。在HLR中拥有MSRN的优点是可以快速提供值，而无需查询VLR。通过提供VLR而不是MSRN的地址，无需刷新HLR中的MSRN。


# 参考文档：

[1]第一章 https://blog.csdn.net/one_of_a_kind/article/details/82502936
[2]第二章 https://blog.csdn.net/one_of_a_kind/article/details/82824938
[3]第三章 https://blog.csdn.net/one_of_a_kind/article/details/82933106
[4]第四章 https://blog.csdn.net/one_of_a_kind/article/details/83050360
[5]第五章 https://blog.csdn.net/one_of_a_kind/article/details/83118052

[Back to Index](#目录)