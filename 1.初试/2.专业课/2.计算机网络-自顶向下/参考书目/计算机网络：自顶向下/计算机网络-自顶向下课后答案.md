# 计算机网络：自顶向下方法，第7版

## 复习题和习题参考答案


### 版本时间：2016年12月

本文档包含Jim Kurose和Keith Ross编写的《计算机网络：自顶向下方法（第7版）》复习题和习题的参考答案。这些答案只对指导老师有效。请不要复制或者分发给其他人（即使是其他指导老师）。请不要在公共网络发布任何参考答案。如果有需要，我们很乐意提供此参考答案（最新版）。

声明：这些年来，很多同学和同事帮助我们准备此参考答案。特别感谢Honggang Zhang，Rakesh Kumar，Prithula Dhungel和VijayAnnapureddy。同时也感谢提建议和修正错误的所有读者。

所有材料©1996-2016 由J.F.Kurose 和K.W.Rose提供。版权所有。


# 说明

译者：李加其

时间：2019-10-6

版本：2019.10.06

电话：13812991101

QQ：1768478912

邮箱：1768478912@qq.com

环境：Manjaro Linux 18.1.0+WPS11.1.0.8865+自带公式编辑器+vscode insider version Markdown

1、此参考答案所有内容版权由原作者所有，本人为了方便考研复习提供简体中文版本的翻译。

2、阁下在获取到此文档的同时，应该同时获取到此文档的英文原版PDF。此文档的中文版权归本人所有，提供给需要的人使用。

3、阁下在使用本文档时，不得添加水印、删减或修改内容。

4、当然，以上内容只是说说而已，你如果不遵守，我也不可能顺着网线去打你。

5、如果有侵权（对于原作者）或者其他的问题或者建议，欢迎联系我。

6、阁下在使用本文档时，请保留此页面和原版翻译的封面。

7、根据南京大学计算机845真题的内容，本文档只翻译第1-7章。

# 目录

[第一章](#第一章)
- [复习题](#复习题1)
- [问题](#问题1)

[第二章](#第二章)
- [复习题](#复习题2)
- [问题](#问题2)

[第三章](#第三章)
- [复习题](#复习题3)
- [问题](#问题3)

[第四章](#第四章)
- [复习题](#复习题4)
- [问题](#问题4)

[第五章](#第五章)
- [复习题](#复习题5)
- [问题](#问题5)

[第六章](#第六章)
- [复习题](#复习题6)
- [问题](#问题6)

[第七章](#第七章)
- [复习题](#复习题7)
- [问题](#问题7)

[参考文档](#参考文档)


# 第一章

## 复习题1

1、（1）没有区别。根据书本内容，“主机”和“终端系统”是交换使用的。

（2）终端系统包括PC、工作站、网络服务器、邮件服务器、PDA、连接网络的游戏控制台等等。

（3）由（2）可知，网络服务器是终端系统。

2、来自维基百科：外交协议常用于描述一系列国家来往规则。这些构建完备和经过时间检验的规则可以使国家和人民生活和工作更简单。协议规则以人民准则为基础，其中的一部分已经作为现在分级的地位声明。

3、标准对于协议来说，可以让人们创建可以相互操作的网络系统和产品。

4、（1）通过电话线的拨号调制解调器：家庭

（2）通过电话线的DSL（Digital Subscriber Line，数字用户线）：家庭或小办公室

（3）混合光纤同轴电缆：家庭

（4）100M交换以太网：企业

（5）无线网：家庭或企业

（6）3G和4G：广域无线网

5、HFC带宽是由用户共享。下行通道中，所有的包都是由头端这一个单一源发出的。因此，下行通道中没有碰撞。

6、光纤到户、3G和4G无线网

7、10M、100M、1G、10G

8、双绞线、光纤

9、拨号调制解调器：最高56K，带宽专用
   ADSL：下行最高24M，上行最高2.5M，带宽专用
   HFC：下行最高42.8M，上行最高30.7M，带宽共享
   FTTH：上行2-10M，下行10-20M，带宽不共享

10、现在最流行的无线网技术有两种：

（1）WiFi。用于无线局域网，无线用户从辐射范围为几十米的基站（例如无线接入点）传输数据包。基站连接无线网络，并为无线用户提供无线网服务。

（2）3G和4G。大范围无线网，此系统通过电信服务商提供的基站，由蜂窝电话通过同一个无线设备传输数据。可以提供基站几十千米范围内的无线网络。

11、$t_0$时发送主机开始传输，$t_1=L/R_1$时发送端完成传输并且交换机收到完整的数据包（没有传播延时）。因为交换机在$t_1$时已收到完整包，那么$t_1$时交换机开始传输包至接收主机。$t_2=t_1+L/R_2$时交换机完成输出并且接收主机收到完整包（没有传播延时）。因此，端到端总延时是$L/R_1+L/R_2$。

12、电路交换网络可以在响应时间内保证一定量的端到端带宽。如今大部分分组交换网络（包括因特网）无法保证端到端带宽。FDM需要复杂的模拟硬件来将信号转换为合适的频率。

13、（1）2个用户，每个用户只需要一半的链接带宽；

   （2）既然每个用户传输时要求1Mpbs带宽，如果两个或者更少的用户同时传输，要求最多2Mbps。共享链路的可用带宽是2Mbps，那么传输前没有排队延时。如果有3个用户同时传输，带宽要求是3Mbps，超过了共享链接可用带宽。这种情况下，连接之前会有排队延时。

   （3） 一个用户传输的概率是0.2

   （4）3个用户同时传输的概率是 $\binom{3}{3} p^{3} (1-p)^{3-3}$ 。因为用户传输是队列会增加，队列增加时的时间因素是0.008。

14、如果两个ISP不对等，那么当他们给对方发送流量时他们需要通过一个付费流量ISP提供商（中间商）来发送数据。通过直接对等传输，两个ISP可以减少给其他ISP提供商的费用。多个ISP可以通过网络交换点（IXP）（通常由它自己的交换机单独构建）作为汇合点来直接对等传输。ISP通过对连接至IXP的每一个ISP收取少量费用来盈利，当然利润取决于IXP发送或接收的流量数。

15、谷歌的私有网络连接了它大大小小的所有的数据中心。谷歌数据中心的流量通过它的私有网络而不是公共网络来传输。大多数的数据中心位于或靠近与低级的ISP。因此，当谷歌向用户分发数据时，可以跳过高级的ISP。是什么推动着这些内容提供商创建这些网络？首先，如果内容提供商使用更少的中间的ISP，它可以更容易控制用户体验。其次，通过减少至提供商的网络流量来节省成本。第三，如果ISP向利润率高的内容提供商收取高费用（在网络中立状态不适用的国家或地区），内容提供商可以避免额外成本。

16、延迟组件包括处理延迟、传输延迟、传播延迟、排队延迟。除了排队延迟是变量其他的都是固定的。

17、a）1000km, 1Mpbs, 100bytes
   b）100km, 1Mpbs, 100bytes

18、（1）10msec
   （2）d/s
   （3）无关
   （4）无关

19、(1) 500kps
   (2) 64 seconds
   (3) 100kps；

20、终端系统A将大文件拆分为块。A通过添加文件头信息至每一个块来从文件生成多个数据包。数据包的头信息包含目标（终端系统B）IP地址。数据包交换机通过包中的目标IP地址来决定发送链接。考虑到包目标地址，包选择哪条路走和包选择哪条外链走的方法相似。

21、最大发送速率为500包/s，最大传输速率是350包/s。相对应的话务量强度是500/350=1.43>1。每次实验最终都会发生数据丢失；由于传输的随机性，每一次实验的数据丢失发生的时间都是不同的。

22、五个功能是：错误控制、流控制、片段化和重组、多任务和连接设置。没错，在不同层这些功能可能重复。例如，不止一层提供错误功能。

23、网络协议的自顶向下的五层是：应用层、传输层、网络层、链路层和物理层。详见1.5.1。

24、应用层报文：应用程序想发送和通过传输层的数据；

   传输层段：由传输层生成并且封装有传输层头信息的应用层报文

   网络层数据段：封装有网络层头信息的传输层段

   链路层帧：封装有链路层头信息的网络层数据段

25、路由器处理网络、链路、物理层（第1到3层）。（实际上现代路由器有时担任防火墙、缓存组件和处理传输层）链路层交换机处理链路层和网络层（第1到2层）。主机处理所有的五层。

26、a）病毒

   需要以下人的交互来传播。比如邮件病毒。

   b）蠕虫

   不需要用户介入。受感染主机中的蠕虫会扫描IP地址和端口号来查找可感染的进程。

27、创建僵尸网络需要攻击者发现以下应用或系统的薄弱点（比如利用应用中可能存在的缓冲区溢出漏洞）。发现薄弱点后，黑客需要查找可攻击的主机。目标一般是已发现漏洞的一系列系统。僵尸网络中的任何系统都可以通过漏洞自动扫描它的环境和传播。这种僵尸网络的重要属性就是僵尸网络的起点可以远程控制和发送命令至僵尸网络中的所有结点的每一个节点（例如僵尸网络中的所有结点可以被黑客命令发送TCP SYN信息至目标，并将导致目标的TCP SYN溢出攻击）。

28、Trudy可以假装为Bob（反之亦然）并且部分或者完全修改Bob发送给Alice的信息。例如，她可以很容易的修改语句“Alice，我欠你1000美元”为“Alice，我欠你10000美元”。更进一步，Trudy甚至可以丢弃Bob发送给Alice的加密信息（反之亦然）。

## 问题2

P1. 这个问题不止一个答案。很多协议都可以解决这个问题。下面是一个简单的答案：

| Msg name | purpose |
|--------- |-------- |
|HELO <userid> | Let server know that there is a card in the ATM machine . ATM card transmits user ID to Server |
|PASSWD <passwd> | User enters PIN, which is sent to server . BALANCE User requests balance |
|WITHDRAWL <amount> | User asks to withdraw money . BYE user all done |

从服务器至ATM机器的信息（显示）

| Msg name | purpose |
|--------- |-------- |
|PASSWD | Ask user for PIN (password) |
|OK | last requested operation (PASSWD, WITHDRAWL) OK |
|ERR | last requested operation (PASSWD, WITHDRAWL) in ERROR |
|AMOUNT <amt> | sent in response to BALANCE request |
|BYE | user done, display welcome screen at ATM |

正确回应：

|client | server |
|-------|--------|
|HELO (userid) | --------------> (check if valid userid) |
| | <------------- PASSWD |
|PASSWD <passwd> | --------------> (check password) |
| | <------------- OK (password is OK) |
|BALANCE |--------------> 
| | <------------- AMOUNT <amt> |
|WITHDRAWL <amt> | --------------> check if enough $ to cover withdrawl |
| | <------------- OK |
|ATM dispenses $ 
|BYE | --------------> |
| | <------------- BYE |

钱不够的情况下：

|client | server |
|-------|--------|
|HELO (userid) |--------------> (check if valid userid) |
| |<------------- PASSWD |
|PASSWD <passwd> |--------------> (check password) |
|| <------------- OK (password is OK) |
|BALANCE |--------------> |
|| <------------- AMOUNT <amt> |
|WITHDRAWL <amt> |--------------> check if enough $ to cover |
withdrawl ||
| |<------------- ERR (not enough funds) |
|error msg displayed ||
|no $ given out ||
|BYE |--------------> |
| | <------------- BYE|

P2. N*(L/R)时，第一个包到达目的地，第二个包存储在最后一个路由器中，第三个包存储在倒数第二个路由器中，等等。N*(L/R)+L/R时，第二个包到达目的地，第三个包存储在最后一个路由器中，等等。按照这个逻辑继续，我们可以看到在N*(L/R)+(P-1)*(L/R)=(N+P-1)*(L/R)时所有数据包到达目的地。

P3.

a.电路交换网，因为应用将以稳定速率，持续长时间运行，因此可以为其保留带宽。

b.不需要，传输速率总和小于链路容量。

P4.

a.
比如：
A 到 B ：4 条
B 到 C ：4 条
C 到 D ：4 条
D 到 A ：4 条
这 16 条可以同时连接。

b.
A 到 B ：4 条
B 到 C ：4 条
最多 8 条。

c.
可以。
A 到 B ：2 条
B 到 A ：2 条
A 到 D ：2 条
B 到 C ：2 条

P5.

a.
收费站将整个车队推向公路的时间为 d1 = 2min；
两收费站之间距离 75 km，从一个收费站到另一个的时间 d2 = 0.75 h
总时间 d = 3d1 + 2d2 = 96min

b.
d1’ = 8辆 / 5辆/min = 1.6min
d’ = 3d1’ + 2d2 = 94.8min

P6.

a.
dprop=m/s

dprop=m/s

b.
dtrans=L/R

dtrans=L/R

c.
de2e=dprop+dtrans=m/s+L/R

de2e=dprop+dtrans=m/s+L/R

d.
刚刚离开 A

e.
在链路上

f.
已经到达 B

g.
dprop = dtrans
m/s = L/R
m = Ls/R = 120b * (2.5 *10^8)m/s / 56kbps = (5.36 * 10^5)m
P7.

主机 A 产生 56 字节的分组需要 = 56 * 8b / 64kbps = 7ms
传输时延 = 56 * 8b / 2Mbps = 0.224ms
总时间 = 7ms + 10ms + 0.224ms = 17.224ms
P8.

a.
3Mbps/150kbps = 20

b.
p = 0.1

c.
(120n)pn(1−p)120−n

(n120​)pn(1−p)120−n

d.
1−∑20n=0(120n)pn(1−p)120−n

1−∑n=020​(n120​)pn(1−p)120−n

根据中心极限定理：
令 Xj
Xj​ 为独立随机变量 P(Xj=1)=pP(Xj​=1)=p ；
P(21或更多用户)=1−P(∑120i=1Xi≤21)P(21或更多用户)=1−P(∑i=1120​Xi​≤21)
P(∑120i=1Xi≤21)=P(∑120i=1Xi≤12120∗0.1∗0.9√≤9120∗0.1∗0.9√)≈P(Z≤93.286)=P(Z≤2.74)=0.997P(∑i=1120​Xi​≤21)=P(120∗0.1∗0.9
​∑i=1120​Xi​≤12​≤120∗0.1∗0.9
​9​)≈P(Z≤3.2869​)=P(Z≤2.74)=0.997
因此 P(21或更多用户)≈0.003

P(21或更多用户)≈0.003
P9.

a.
N=1Gbps100kbps=104

N=100kbps1Gbps​=104

b.
∑Mn=N+1(Mn)pn(1−p)M−n

∑n=N+1M​(nM​)pn(1−p)M−n
P10.

Dtrans=L/R1+L/R2+L/R3
Dtrans=L/R1+L/R2+L/R3
Dprop=d1/s1+d2/s2+d3/s3Dprop=d1/s1+d2/s2+d3/s3
Dprop=2∗dprocDprop=2∗dproc
D=Dtrans+Dprop+DprocD=Dtrans+Dprop+Dproc
D=6+6+6+20+16+4+3+3=64ms

D=6+6+6+20+16+4+3+3=64ms
P11.

D=Dprop+L/R=20+16+4+6=46ms

D=Dprop+L/R=20+16+4+6=46ms
P12.

有一个完整分组的排队时延为 1500∗8b2Mbps=0.6ms
2Mbps1500∗8b​=0.6ms
4.5个分组的总排队时延为 4.5∗0.6ms=2.7ms

4.5∗0.6ms=2.7ms

一般情况：
LnR+L−xR

RLn​+RL−x​
P13.

a.
第一个分组的排队时延为 0, 第二个 L/R, 第三个 2L/R，第N个 (N-1)L/R
因此平均排队时延为 (L/R + 2L/R + … + (N-1)L/R) / N = (N-1)L/2R

b.
当下一批 N 个分组到达时，上一批已经传完，因此平均排队时延为 (N-1)L/2R
P14.

a.
IL/R(1-I) + L/R = L/R(1-I)

b.
以 L/R 为函数：
令 x = L/R： L/R(1-I) = x/(1-ax)
函数经过原点，在 x = 1/a 处趋于无穷
P15.

μ = R/L 所以 L / R(1-I) = 1 / μ-a
P16.

N = 10 + 1 = 11个分组
d = 10ms + 1/100s = 0.02s
a = N/d = 11/0.02 = 550分组/s
P17.

a
设有 N - 1 台路由器，则 de2e=∑Ni=1diproc+diprop+ditrans

de2e​=∑i=1N​dproci​+dpropi​+dtransi​

b.
de2e=∑Ni=1diproc+diprop+ditrans+diqueue

de2e​=∑i=1N​dproci​+dpropi​+dtransi​+dqueuei​
P18.

略
P19.

略
P20.

min{Rs, Rc, R/M}
P21.

仅使用一条：
max{min{R11,R12,...,R1N},min{R21,R22,...,R2N},...min{RM1,RM2,...,RMN}}

max{min{R11​,R21​,...,RN1​},min{R12​,R22​,...,RN2​},...min{R1M​,R2M​,...,RNM​}}

使用 M 条：
∑Mk=1min{Rk1,Rk2,...,RkN}

∑k=1M​min{R1k​,R2k​,...,RNk​}
P22.

不丢包概率为 1 - p， N 个路由器， 因此总的不丢包概率 (1−p)N
(1−p)N
一个分组被接收所需要的平均次数为 1(1−p)N(1−p)N1​，因此重传次数为 1(1−p)N−1

(1−p)N1​−1
P23.

a.
L/Rs

b.
可能，因为第二个分组 (用 P2 表示) 可能在第一个分组 (P1) 被推出之前到达；

P1 被完全推出的时间 t1 = L/Rs + L/Rc + dprop
P2 到达路由器的时间 t2 = 2L/Rs + dprop + T
要求 t2 > t1:
                  即 T > L/Rc - L/Rs；
因此 T 至少是 L/Rc - L/Rs
P24.

t = 40 * 10^12 * 8b / 100Mbps = 3.2 * 10^6 s = 888h = 37 天
所以使用 FedEx
P25.

a.
tprop = 20000km / 2.5*10^8m/s = 0.08s
R * tprop = 1.6 * 10^5 b

b.
1.6 * 10^5 b

c.
链路上的最大比特数量

d.
20000km / 1.6*10^5 = 125m
这比足球场长(正规足球场场地：长105米、宽68米)

e.
s/R
P26.

s/R = 20000km
R = 12.5Mbps
P27.

a.
R * dprop = 8 * 10^7 b

b.
8 * 10^7 b 是 不对 的，因为文件为 8 * 10^5 b，因此为 8 * 10^5 b

c.
s/R = 0.25m
P28.

a.
ttrans + tprop = 0.48s

b.
20 * (ttrans’ + tprop) = 20 * (0.02 + 0.08)s = 2s

c
(b)花的时间更长
P29.

a.
dprop = 36000km / (2.4 * 10^8) = 0.15s

b.
R * dprop = 10Mbps * 0.15s = 1.5 * 10^6 b

c.
60s * 10Mbps = 6 * 10^8 b
P30.

有，略
P31.

a.
8 * 10^6 / 2Mbps = 4s
3 * 4s= 12s

b.
1 * 10^4 b / 2Mbps = 5 * 10^(-3)s
5 * 10^(-3)s
5 * 10^(-3)s
2 * 5 * 10^(-3)s = 10^(-2)s

c.
(800 + 3 - 1) * 0.5 * 10^(-2) = 4.01s
比 (a) 快非常多

d.
便于检测错误并重传；不分段的大包容易使路由器缓存不足导致丢包；

e.
分组需要排序；需加上首部信息；
P32.

略
P33.

D = (3 + F/S - 1) * (80 + R) /R = (2 + F/S)(80 + S) / R
ddSD=0
dSd​D=0 因此 S=40F−−−−√S=40F

​
P34.

略


# 第二章

## 复习题2
R1.

web：http；文件传输：FTP；邮件：SMTP；P2P：Bittorrent；远程登录：telnet
R2.

网络体系结构指的是五层模型，应用程序体系结构指的是 P2P 或者 客户-服务器
R3.

先发起对话的是客户，接收请求的是服务器
R4.

不同意，发送文件的对等方通常被称为服务器，接收文件的被称为客户
R5.

端口和 IP
R6.

UDP
R7.

QQ
R8.

    可靠数据传输：TCP 提供
    吞吐量：都不提供
    定时：都不提供
    安全性：都不提供

R9.

SSL 运行在应用层；
如果想要强化TCP，需要把 SSL 的代码写到程序里；
中文版的课本上写的是 UDP，UDP 不能用 SSL；
R10.

握手协议是指主要用来让客户端及服务器确认彼此的身份的一类网络协议
R11.

因为这些应用都需要可靠传输服务，而 UDP 不能提供
R12.

当用户初次访问网站时，服务器创建一个独一无二的标志数，在返回客户端的报文中发送给用户，这个数被称为 cookie，由浏览器维护；当用户请求查看购物车时，cookie 插在报文中被发送到服务器，服务器返回特定 cookie 对应的购物车信息
R13.

Web 缓存器中保存最近请求过的对象的副本。会减少所有对象的时延。
R14.

USER@NAME:~# telnet httpd.apache.org 80
Trying 40.79.78.1...
Connected to httpd.apache.org.
Escape character is '^]'.
GET /index.html HTTP/1.1
Host: httpd.apache.org
If-Modified-Since: Sat, 22 Sep 2018 11:41:57 GMT

HTTP/1.1 304 Not Modified
Date: Tue, 02 Oct 2018 07:19:28 GMT
Server: Apache/2.4.18 (Ubuntu)
ETag: "24ea-576743e4db26f"

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

R15.

FTP 有一条控制连接，一条数据连接
R16.

首先报文通过 HTTP 传送到 Alice 的邮件服务器，然后服务器通过 SMTP 将报文发送到 Bob 的服务器，然后 Bob 用 POP3 接收这个报文
R17.

手动打码 (ಡωಡ)

USER@NAME:~# telnet pop.163.com 110
Trying 123.125.50.29...
Connected to pop3.163.idns.yeah.net.
Escape character is '^]'.
+OK Welcome to coremail Mail Pop3 Server (163coms[b62aaa251425b4be4eaec4ab4744cf47s])
user ****@163.com
+OK core mail
pass ****
+OK 3 message(s) [9082 byte(s)]
list
+OK 3 9082
1 3406
2 2376
3 3300
.
TOP 1 0
+OK 3406 octets
Received: ****
Date: ****
From: ****
To:****@163.com
...

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22

各头部信息可以参考 RFC 5321
R18.

下载并删除模式对用户来说是不友好的，用户无法第二次查看邮件
下载并保留模式是不方便的，因为很久远的邮件也会保留下来
R19.

Web服务器可以和邮件服务器有相同的别名
包含邮件服务器的 RR 是 MX
R20.

能确定，而 gmail 却不行
R21.

不需要，Alice 必须是 Bob 的上传速率最高的 4 个邻居
R22.

在 Bittorrent 中，对等方们每过 30 秒随机选择另外的一个邻居发送块，当 Alice 被随机选中时，她将得到第一个块
R23.

覆盖网络不包含路由器，是对等方组成的逻辑网络，不是物理链路，边是两个对等方之间有 TCP 连接。
R24.

网状 DHT：
优点很明显，大大减少用于查询的时间和报文数量
缺点是每个对等方必须追踪其他所有对等方

环形 DHT：
优点是追踪的对等方少
缺点是查询时间长，报文数量多
R25.

文件下载，即时讯息，网络直播，分布式计算
R26.

TCP 有一个欢迎套接字，一个连接套接字
n + 1
R27.

TCP 需要建立连接，UDP 不需要

## 习题2

P1.

a. 错
b. 对
c. 错
d. 错
e. 错
P2.

FTP SERVICE COMMANDS:

         RETRIEVE (RETR)

         STORE (STOR)

         STORE UNIQUE (STOU)

         APPEND (with create) (APPE)

         ALLOCATE (ALLO)

         RESTART (REST)

         RENAME FROM (RNFR)

         RENAME TO (RNTO)

         ABORT (ABOR)

         DELETE (DELE)

         REMOVE DIRECTORY (RMD)

         MAKE DIRECTORY (MKD)

         PRINT WORKING DIRECTORY (PWD)

         LIST (LIST)

         NAME LIST (NLST)

         SITE PARAMETERS (SITE)

         SYSTEM (SYST)

         STATUS (STAT)

         HELP (HELP)

         NOOP (NOOP)

P3.

应用层：DNS HTTP
运输层：TCP(HTTP需要) UDP(DNS需要)
P4.

a.
gaia.cs.umass.edu/cs453/index.html

b.
1.1

c.
持续

d.
HTTP 报文中没有 IP 地址

e.
Mozilla/5.0 可以针对不同的浏览器发送不同版本的网页
P5.

a.
能
Tue, 07 Mar 2008 12:39:45 GMT

b.
Last-Modified: Sat, 10 Dec 2005 18:27:46 GMT

c.
Content-Length: 3874

d.
前五个字节："<!doc"
根据 keep-alive 看出同意持续连接
P6.

a.

   An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
   maintain a persistent connection unless a Connection header including
   the connection-token "close" was sent in the request. If the server
   chooses to close the connection immediately after sending the
   response, it SHOULD send a Connection header including the
   connection-token close.

   An HTTP/1.1 client MAY expect a connection to remain open, but would
   decide to keep it open based on whether the response from a server
   contains a Connection header with the connection-token close. In case
   the client does not want to maintain a connection for more than that
   request, it SHOULD send a Connection header including the
   connection-token close.

   If either the client or the server sends the close token in the
   Connection header, that request becomes the last one for the
   connection.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

意思就是双方都可以关闭连接

b.
HTTP 并没有提供什么加密服务

c.

    Clients that use persistent connections SHOULD limit the number of
   simultaneous connections that they maintain to a given server. A
   single-user client SHOULD NOT maintain more than 2 connections with
   any server or proxy. A proxy SHOULD use up to 2*N connections to
   another server or proxy, where N is the number of simultaneously
   active users. These guidelines are intended to improve HTTP response
   times and avoid congestion.

    1
    2
    3
    4
    5
    6
    7

意思是客户最多可以和给定服务器有两条并行连接

d.

    A client, server, or proxy MAY close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

    1
    2
    3
    4
    5
    6

意思是一侧关闭连接而另一侧正在传输数据是可能的。
P7.

得到IP地址的时间 = RTT1 + RTT2 + … + RTTn
三次握手加上最后的响应 = 2 RTT0
因此总共是 2 RTT0 + RTT1 + RTT2 + … + RTTn
P8.

a.
2RTT0 + RTT1 + RTT2 + … + RTTn + 8 * 2 RTT0 = 18 RTT0 + RTT1 + RTT2 + … + RTTn

b.
2RTT0 + RTT1 + RTT2 + … + RTTn + 2 * 2 RTT0 = 6 RTT0 + RTT1 + RTT2 + … + RTTn

c.
2RTT0 + RTT1 + RTT2 + … + RTTn + RTT0 = 3 RTT0 + RTT1 + RTT2 + … + RTTn
P9.

a.
Δ = 850000b / 15Mbps = 0.0567s
β = 16请求/s
t接 = Δ/1-Δβ = 0.61s
t总 = t接 + t因 = 3.61s

b.
英文版是不命中率为0.4，这里按中文版做：
β’ = 16请求/s * 60%
t接’ = Δ/1-Δβ = 0.12s
当命中缓存器时: t命 = 850000b / 100Mbps = 0.0085s
因此 t总’ = 0.4 * 0.0085 + 0.6(t接’ + t因) = 1.8754s
P10.

10米短链路，忽略其传播时延。

带有并行连接的非持续连接且并行下载：
(200b / 150bps) * 3 + ((10^5)b/ 150bps) + (200b / (150bps / 10)) * 3 + ((10^5)b / (150bps / 10)) = 7377.3s

持续连接：
(200b / 150bps) * 3 + ((10^5)b / 150bps) + 10 * (200b/150bps + (10^5)b/150bps) = 7351s
P11.

a.
毫无疑问，是可以的，这里不做证明

b.
仍然是可以的
P12.

服务器代码：

from socket import *
import threading
def Accept(ConnectionSocket, Addr):
	Message = ConnectionSocket.recv(1024).decode('utf-8', 'ignore')
	print(Message)
	ConnectionSocket.send('haha'.encode('utf-8', 'ignore')) 
	ConnectionSocket.close()

ServerPort = 10000
ServerSocket = socket(AF_INET, SOCK_STREAM) 
ServerSocket.bind(('',ServerPort))
ServerSocket.listen()
print('listening...')
while 1:
	ConnectionSocket, Addr = ServerSocket.accept() 
	t = threading.Thread(target=Accept, args=(ConnectionSocket, Addr))
	t.start()

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17

比如我先访问 http://httpd.apache.org，然后打开服务器程序，在浏览器里设置服务器程序为代理，然后再用浏览器刷新一次，出现了以下报文，说明浏览器使用了条件GET报文。如果不成功，可能要多试几次。·

GET http://httpd.apache.org/ HTTP/1.1
Host: httpd.apache.org
...
If-Modified-Since: Sat, 22 Sep 2018 11:41:57 GMT
...

    1
    2
    3
    4
    5

P13.

MAIL FROM 是 SMTP 握手协议的一部分，而 From 是邮件报文的一部分。
P14.

SMTP 使用仅包含一个句号的一行来标志报文体结束，HTTP 使用 Content-Length 标志。
不能，因为报文内容可能含有句号。
P15.

In particular, SMTP servers and clients provide a mail transport service
   and therefore act as "Mail Transfer Agents" (MTAs).  "Mail User
   Agents" (MUAs or UAs) are normally thought of as the sources and
   targets of mail.  At the source, an MUA might collect mail to be
   transmitted from a user and hand it off to an MTA; the final
   ("delivery") MTA would be thought of as handing the mail off to an
   MUA (or at least transferring responsibility to it, e.g., by
   depositing the message in a "message store").  However, while these
   terms are used with at least the appearance of great precision in
   other environments, the implied boundaries between MUAs and MTAs
   often do not accurately match common, and conforming, practices with
   Internet mail.  Hence, the reader should be cautious about inferring
   the strong relationships and responsibilities that might be implied
   if these terms were used elsewhere.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14

意思是 MTA(Mail Transfer Agents) 其实就是提供邮件传输服务的 SMTP 服务器和客户端。

When forwarding a message into or out of the Internet environment, a
   gateway MUST prepend a Received: line, but it MUST NOT alter in any
   way a Received: line that is already in the header section.

    1
    2
    3

Received 是 在将消息转发到 Internet 环境或从 Internet 环境转发消息时，网关必须预先添加 Received 行，并且它不得以任何方式更改已在标题部分中的 Received 行。
因此排在最后面的 Received 行所指示的地址就是源地址，即 58.88.21.177
P16.

 which uniquely identifies a message within a
          maildrop and which persists across sessions. 

    1
    2

UIDL 即 unique-id listing，可以唯一定位一个消息
P17.

a.

list
+OK 3 14907
1 9125
2 3406
3 2376
.
retr 1
blah blah ...
..........blah
.
dele 1
+OK core mail
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14

b.

list 
+OK 2 5782
2 3406
3 2376
.
retr 2
blah blah ...
..........blah
.
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11

c.

list
+OK 2 5782
2 3406
3 2376
.
retr 3
blah blah ...
..........blah
.
retr 2
blah blah ...
..........blah
.
quit
+OK core mail

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15

P18.

a.
whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。

b.
Name Server: ns2.google.com
Name Server: ns1.google.com
Name Server: ns4.google.com
Name Server: ns3.google.com
我用的是 linux 上的 whois 命令

c.
在 windows 打开 cmd，使用 nslookup 命令

nslookup 用法:
   nslookup [-opt ...]             # 使用默认服务器的交互模式
   nslookup [-opt ...] - server    # 使用 "server" 的交互模式
   nslookup [-opt ...] host        # 仅查找使用默认服务器的 "host"
   nslookup [-opt ...] host server # 仅查找使用 "server" 的 "host"
比如
nslookup -qt=mx 163.com ns6.nease.net
-qt 可以指示类型

    1
    2
    3
    4
    5
    6
    7
    8

d.

C:\>nslookup www.baidu.com
服务器:  *
Address:  *.*.*.*

非权威应答:
名称:    www.a.shifen.com
Addresses:  111.13.100.92
          111.13.100.91
Aliases:  www.baidu.com

    1
    2
    3
    4
    5
    6
    7
    8
    9

可以看到百度有两个 web 地址

e.
自行查询吧

f.
攻击者可以通过 whois 和 nslookup 查询到目标的 IP 地址，DNS 服务器等

g.
whois 是用来查询域名的IP以及所有者等信息的传输协议，简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。
P19.

a.
以下是 gaia.cs.umass.edu 的查询委托链路：
首先查询根服务器，然后总是选择第一个服务器，最后就可以查到 gaia.cs.umass.edu 的 IP 地址

# dig +norecurse @a.root-servers.net any gaia.cs.umass.edu
...
;; AUTHORITY SECTION:
edu.			172800	IN	NS	f.edu-servers.net.
edu.			172800	IN	NS	a.edu-servers.net.
edu.			172800	IN	NS	g.edu-servers.net.
edu.			172800	IN	NS	l.edu-servers.net.
edu.			172800	IN	NS	c.edu-servers.net.
edu.			172800	IN	NS	d.edu-servers.net.
...

# dig +norecurse @f.edu-servers.net any gaia.cs.umass.edu
...
;; AUTHORITY SECTION:
umass.edu.		172800	IN	NS	ns1.umass.edu.
umass.edu.		172800	IN	NS	ns3.umass.edu.
umass.edu.		172800	IN	NS	ns2.umass.edu.
...

# dig +norecurse @ns1.umass.edu any gaia.cs.umass.edu
...
;; ANSWER SECTION:
gaia.cs.umass.edu.	21600	IN	MX	0 barramail.cs.umass.edu.
gaia.cs.umass.edu.	21600	IN	A	128.119.245.12
...

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25

b.
查询 google.com 时的链路，类似的：
a.edu-servers.net
a.gtld-servers.net
ns2.google.com
P20.

在一段时间内， DNS 服务器缓存中出现最频繁的 web 服务器就是最流行的
P21.

很简单，只需要输入这样的命令dig server，把 server 改成你想测试的网站名，如果 Query time 极短，说明最近可能有人访问过该网站。
P22.

客户-服务器：
与 u 无关， t = max{NF/us, F/di}
N 	t
10 	7500s
100 	50000s
1000 	500000s

P2P：
t = max{F/us, F/di, NF/(us+Nu)}
t 	N 	10 	100 	1000
    u 				
300kps 		7500s 	25000s 	45454.5s
700kps 		7500s 	15000s 	20547.9s
2Mbps 		7500s 	7500s 	7500s
P23.

a.
服务器向每个客户端并行发送文件，此速率为 us/N，因为 us/N <= dmin，所以客户端也以该速率下载。则每个客户端接收完文件的时间为 F / (us / N) = NF / us

b.
仍然考虑服务器向每个客户端并行发送文件，以 dmin 为速率，因为 us/N >= dmin，所以 us >= Ndmin，故服务器可以承受此速率，各服务器以 dmin 为下载速率，故接收时间为 F/dmin

c.
当 us/N <= dmin 时：
        N/us >= 1/dmin
        NF/us >= F/dmin
        此时 t = NF/us = max{NF/us, F/dmin}
当 us/N >= dmin 时：
        N/us <= 1/dmin
        NF/us <= F/dmin
        此时 t = F/dmin = max{NF/us, F/dmin}

因此：得出最小分发时间为 max{NF/us，F/dmin}
P24.

太难了。。。。
P25.

N，N(N-1)/2
P26.

a.
这是可能的，BitTorrent 存在漏洞，不能防止不合作的搭便车行为。
比如 BitThief，它声称自己可以从 BitTorrent swarm 上下载却无需贡献任何资源

b.
他可以在每台主机上都运行客户端，并使他们搭便车，然后将它们收集的块聚合成一个文件，他还可以使不同主机下载不同的块，这是实际上一种 Sybil 攻击。
P27.

对等方 3 可以查它的第二后继对等方 4，使对等方 4 返回它的第一后继对等方 8。
对等方 3 的第一后继是对等方 4，第二后继是对等方 8
P28.

查询会顺时针一直到对等方 5，对等方 5 知道 6 要成为其后继， 6 的后继为 8， 然后 5 向 6 发送 6 的前后继信息，6 接收之后就可以加入 DHT 了。
P29.

对任意 key，可以计算它与所有对等方的距离，将其存放在距离它最近的对等方。
P30.

可能。随机分配标志符而不考虑物理链路，确实会造成错误匹配，逻辑上的“邻居”可能在物理上相距十万八千里。
P31.

a.
会出错

Traceback (most recent call last):
  File "./TCPclient.py", line 5, in <module>
    ClientSocket.connect((ServerName,ServerPort))
ConnectionRefusedError: [Errno 111] Connection refused

    1
    2
    3
    4

b.
没有什么影响

c.
TCP 肯定会报错
P32.

没有必要修改 UDPServer.py。
源端口号 5432，目的端口号 12000
源端口号是随机的
P33.

可以，参考这篇博客 https://blog.csdn.net/williham/article/details/7251091
P34.
P35.

Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。
它是自由软件。
它的一些功能：

    Loadable Dynamic Modules
    Multiple Request Processing modes (MPMs) including Event-based/Async, Threaded and Prefork.
    Highly scalable (easily handles more than 10,000 simultaneous connections)
    Handling of static files, index files, auto-indexing and content negotiation
    .htaccess support[17]
    Reverse proxy with caching[18]
        Load balancing[19] with in-band health checks
        Multiple load balancing mechanisms
        Fault tolerance and Failover with automatic recovery
        WebSocket, FastCGI, SCGI, AJP and uWSGI support with caching
        Dynamic configuration[20]
    TLS/SSL with SNI and OCSP stapling support, via OpenSSL.
    Name- and IP address-based virtual servers
    IPv6-compatible
    HTTP/2 protocol support
    Fine-grained authentication and authorization access control[21]
    gzip compression and decompression
    URL rewriting[22]
    Headers[23] and content[24][25] rewriting
    Custom logging with rotation
    Concurrent connection limiting
    Request processing rate limiting
    Bandwidth throttling
    Server Side Includes[26]
    IP address-based geolocation
    User and Session tracking[27]
    WebDAV
    Embedded Perl, PHP and Lua scripting
    CGI support[28]
    public_html per-user web-pages[29]
    Generic expression parser[30]
    Real-time status views[31]
    XML support[32]
    FTP support (by a separate module) [33]

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34

P36.

键是 torrent 的 infohash，值是存有当前 infohash 指示的文件的 IP 地址

# 第三章

## 复习题3

复习题
R1.

a.
称这个简单的运输层协议为 STP。
在发送端，STP 接收应用程序要发送的数据（不超过 1196 字节）、目的地址、端口号；然后 STP 添加 4 字节头部信息，即端口号；将这 1200 字节的报文段连同目的地址交付给网络层；
在接收端，STP 提取端口和数据，将数据发送给端口所标志的程序。

b.
在头部信息中增加 4 字节的源端口号，将数据减少为 1192 字节。

c.
不。
R2.

略
R3.

y、x
R4.

一些应用程序不想使用 TCP，因为其拥塞控制会降低发送速率。而且应用本身并不需要可靠的数据传输。
R5.

因为今天大多数的防火墙会拦截 UDP
R6.

在应用层添加差错检测，需要程序开发人员在程序中添加一些检测代码
R7.

题目正确的翻译应该是：这两个报文段都将被定向到主机C上的同一个套接字吗？还不如直接 google 翻译呢。那么现在题目要求清楚了，两个报文段都将被定向到主机C上的同一个套接字。根据源 IP 区分不同主机。
R8.

通过不同的欢迎套接字。它们的目的端口都是 80。
R9.

判断究竟是新的分组还是重传
R10.

处理丢包事件，如果丢包可以重传
R11.

RTT 固定的好处就是发送方可以准确判断 ACK 是否丢失，不过它仍需要一个时间固定的定时器。
R12.

a.
接收方丢弃全部分组，之后发送方重传五个分组。

b.
GBN 使用累积确认，因此没有触发重传

c.
只能发送五个，因为窗口大小就是 5
R13.

a.
只重发第一个分组即可

b.
超时重发第一个分组

c.
只能发送五个，因为窗口大小就是 5
R14.

a. 错
b. 错
c. 对
d. 错
e. 对
f. 错
g. 错
R15.

a. 110 - 90 = 20byte
b. 90
R16.

依然是三个，第一个 seq=43 ack=80，第二个 seq=80 ack=44，第三个 seq=44 ack=81
R17.

R/2
R18.

错，设为 cwnd 的一半
R19.

略
习题
P1.

假定 A 向 S 的源端口号为 x， B 向 S 的源端口号为 y
a.
A 向 S 的源端口号为 x， 目的端口号为 23

b.
B 向 S 的源端口号为 y， 目的端口号为 23

c.
S 向 A 的源端口号为 23， 目的端口号为 x

d.
S 向 B 的源端口号为 23， 目的端口号为 y

e.
x y 可能相同

f.
不可能
P2.

从 B 到 C：
   左边的连接：源端口号 80，源 IP 为 B 的 IP；目的端口 26145，目的 IP 为 C 的 IP；
   右边的连接：源端口号 80，源 IP 为 B 的 IP；目的端口 7532，目的 IP 为 C 的 IP；

从 B 到 A：
   源端口号 80，源 IP 为 B 的 IP；目的端口 26145，目的 IP 为 C 的 IP；
P3.

注意应在溢出时向最低位进位：

    01010011  
+   01100110 
————————————
    10111001
+   01110100
————————————
(1) 00101101
+          1
————————————
    00101110

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

其反码为 11010001

使用反码有以下好处：

    不依赖系统是大端还是小端
    计算检验和比较简单快速

接收方检验差错的方法是将三个字节与检验和相加，如果任何一个位为 0，说明出错

1比特的差错肯定会导致结果不同
2比特的差错可能会检测不出，比如题中第一、二字节变为 01010010，01100111，即最后一个比特反转
P4.

a. 00111110
b. 01000000
c. a 中的第一、二字节变为 01011101、01100100
P5.

不能确保，如同上两题讨论的那样
P6.

如果 rdt2.1 发送方正处于“等待来自上层的调用0”，接收方处于“等待来自下层的0”，发送方发送序号为 0 的分组，而接收方正确接收并向发送方发送 ACK；此时发送方处于“等待 ACK 或 NAK 0”，接收方处于“等待下层的 1”，如果此 ACK 损坏，发送方重发序号0的分组，而接收方会发送 NAK，这将导致一个死循环；
其实此接收方并没有标注初始状态，如果发送方初始状态为“等待来自上层的 0”，接收方初始为“等待下层的 1”，也会导致上述死锁。
P7.

ACK 分组没有序号是因为接收方、发送方都不需要该序号。
P8.

可以直接使用 rdt2.2 中的接收方
P9.

图片2张

数据分组损坏
确认分组损坏
P10.

类似于 rdt3.0 的发送方，在 rdt2.1 的发送方上加上 start_timer 以及 timeout 事件即可。timer 的时间要大于最大往返时延。
P11.

如果从“等待来自下层的1”中删除，不会影响正常工作，因为 sndpkt 已经被生成了。
但是如果从“等待来自下层的0”中删除，而且接收方刚刚启动（处于初始状态），sndpkt 是一个错误的值（很可能是一个随机值），那么发送方会认为 ACK 损坏并重发分组，接收方会继续发送错误值，浙江导致一个死锁。
P12.

仅有一个比特差错时，协议正常工作，只不过可能比 rdt3.0 发送方反应更快。
而当定时器时间过短时，每一个超时重发的分组都将会导致正在发送的包重发，这样从第一个包累积到第n个包，分组发送的次数将趋于无穷。
P13.

图片一张

像图片展示的那样，两个 M0 将无法区分
重排序
P14.

分组 x 丢失只能被接收方检测到，且只有 x-1，x+1 都被接收后。如果发送方在发送 x 之后隔较长时间才发送 x+1，那么这段时间 x 将一直不会被重发。
而当数据量较大且很少丢包时，用 NAK 协议发送的数据包的数量明显比 ACK 协议少
P15.

中文版翻译较差，错误极多，无力吐槽。。。这里按英文版的 98% 来做：
U = (nL/R) / (RTT + L/R) > 98%
    解出 n > 2450.98
    因此 n 至少是 2451
P16.

肯定能增加利用率，接收到 ACK0 或 ACK1 之后发送方认为分组已经成功到达，即使事实不是如此。
可能导致许多问题，例如差错出现并不会重发、造成无谓的重发等。
P17.
图1张

B与A类似，只不过初始状态从 receive from A 开始
A
P18.

略
P19.

略
P20.

略
P21.

略
P22.

a.
考虑两种极端情况：

    发送方发送 k-4，k-3，k-2，k-1，接收方都完整得接收并发送 ACK，但 ACK 全都未传到发送方，接收方的期待序号为 k，而发送方窗口序号为 [k-4, k-1]
    如果 ACK 全都传回，则发送方更新 base，其序号为 [k, k+3]

因此序号可能是 [k-4, k+3]

b.
如果接收方期待 k，则它一定将比 k-1 小的 ACK 发送出去了，如果要使发送方发送 k-1，那么它至少已经接收到了 k-5 的 ACK。
因此正在传播回发送方的 ACK 序号可能是 [k-4, k-1]
P23.

设序号为 0（第一个 0），1，…，k-1，0（第二个 0）

对于 SR，要使其序号发生混杂，至少是当接收方刚刚包含第二个 0，即接收方窗口为[k-N-1, 0]，也就是说 k-N (包括 k-N) 之前的都接收过了。要使序号混杂还有一个条件就是第一个 0 在发送方窗口且恰好其 ACK 丢失，需要重发。0(第一个0)~k-N 为 k-N+1 个值，如果窗口长度不足 k-N+1，则第一个 0 和第二个 0 不会同时包含在发送或接收窗口中。
所以窗口长度 N <= k-N，即 N <= k/2

GBN 类似，N <= k 即可
P24.

a.
可能， ACK 还没来得及返回，发送方超时重发，之后发送方接收到 ACK 并移动窗口，那么它之前重发的分组的 ACK 将落在窗口之外

b.
可能，类似 a

c.
是的

d.
是的
P25.

a.
UDP 直接将用户数据打包进报文并立即传输，而 TCP 会将数据写进缓存并可能分成多个报文

b.
TCP 有流量控制和拥塞控制，而 UDP 没有
P26.

a.
注意到 TCP 是字节流编号的， L 的最大值为 2^32 byte

b.
设 N 为报文数：
N=⌈232536⌉=8012999

N=⌈536232​⌉=8012999

总头部长=N∗66byte=528857934byte

总头部长=N∗66byte=528857934byte

总字节数=232byte+528857934byte=4.824∗109byte

总字节数=232byte+528857934byte=4.824∗109byte

t=总字节数155Mbps=249s

t=155Mbps总字节数​=249s
P27.

a.
序号、源、目的端口号分别为 207、302、80

b.
序号、源、目的端口号分别为 207、80、302

c.
127

d.
p27
图片一张
P28.

TCP 让发送方 A 维护一个接收窗口来提供流量控制，主机 B 将实时的 rwnd 值放入发给 A 的报文中，通知 B 的缓存大小。A 确保 LastByteSent - LastByteAcked <= rwnd，当缓存不足时，将暂停向 B 发送数据
P29.

a.
防止有攻击者发动 SYN 洪泛攻击

b.
不能。当服务器使用 SYN cookie 时，它不维护 cookie 或其他信息，因此半开连接不可行。攻击者并不知道某个服务器和某 IP 对应的初始序列号，因为那个秘密数只有服务器知道。

c.
理论上可行
P30.

a.
超时值是固定的，单一得增加有限缓存的长度，会导致未丢失的分组被重传

b.
有助于。
P31.

略，自己慢慢算算吧
P32.

a.
EstimatedRTT’
= 0.9 ( 0.9 ( 0.9 ( 0.9 EstimatedRTT + 0.1 SampleRTT1 ) + 0.1 SampleRTT2 ) + 0.1 SampleRTT3 ) + 0.1 SampleRTT4
= 0.9^4 EstimatedRTT + 0.1 SampleRTT4 + 0.9 * 0.1 SampleRTT3 + 0.9^2 * 0.1 SampleRTT2 + 0.9^3 * 0.1 SampleRTT1

b.
推广到 n：
EstimatedRTT’ = 0.9^n EstimatedRTT + 0.9^(n-1) * 0.1 SampleRTT1 + 0.9^(n-2) * 0.1 SampleRTT2 + … + 0.1 SampleRTTn

c.
根据上式：
EstimatedRTT′=0.9nEstimatedRTT+110∑ni=10.9n−iSampleRTTi

EstimatedRTT′=0.9nEstimatedRTT+101​∑i=1n​0.9n−iSampleRTTi​

可以看出 i 越小，SampleRTTi
SampleRTTi​ 对 EstimatedRTT′

EstimatedRTT′ 的影响越小，且其权重呈指数形式锐减
P33.

假设传递分组 1 到目的地，超时后源又重发分组 1 的副本分组 2；如果分组 1 的 ACK 返回到源，则源可能将它作为分组 2 的 ACK，从而计算了一个错误的 RTT
P34.

SendBase - 1 <= LastByteRcvd
LastByteRvcd 是刚到达 B 的编号， SendBase - 1 是已经到达 B 的编号
P35.

y 之前的所有字节都被接收，因此 y-1 <= LastByteRcvd
P36.

考虑当分组错序到达会发生什么，分组 1 正确到达，目的地发送 ACK，分组 3 提前于分组 2 到达，发送一个冗余 ACK，这将导致发送方重传分组 2，即使分组 2 并未丢失
P37.

a.
GBN：
A：首先发送分组 12345，后来重发 2345，总共 9 个分组
B：首先发送 ACK 1111，后来发送 2345，总共 5 个 ACK

SR：
A：首先发送分组 12345，后来重发 2，总共 6 个分组
B：首先发送 ACK 1345，后来发送 2，总共 5 个 ACK

TCP：
A：首先发送分组 12345，后来重发 2，总共 6 个分组
B：首先发送 ACK 2222，后来发送 6，总共 5 个 ACK

b.
GBN、SR 需要等待超时，而 TCP 使用快速重传，故 TCP 最快
P38.

是的
P39.

λ’in 超过 R/2，会导致更多的丢包以及重传，λout 可能会下降
P40.

a. [1, 6] 和 [23, 26]

b. [6, 16] 和 [17, 22]

c. 三个冗余 ACK

d. 超时

e. 32

f. 42/2 = 21

g. 29/2 = 14

h. 分组 1 (p1) 在传输轮回 1 (t1) 中发送，p2~p3 在 t2 中发送，p4~p7 在 t3 中发送，p8~p15 在 t4，p16~p31 在 t5，p32~p63 在 t6，p64~p96 在 t7,
因此分组 70 在第 7 个传输轮回内发送

i. ssthresh = 4，cwnd = ssthresh + 3MSS = 7

j. 在第16个传输轮回时，ssthresh = cwnd/2 = 21，cwnd = 1 并进入慢启动状态，则在第19个传输轮回中，ssthreash = 21，cwnd = 4

k. t17：1个，t18：2个，t19：4个，t20：8个，t21：16个，t22：21个
1 + 2 + 4 + 8 + 16 + 21 = 52 个
P41.
图片一张
从图中可以看出，这不是一种平等算法
p41

P42.

超时仅能减缓 分组未丢失超时重传 这种情况，不能阻止 TCP 向可能出现拥塞的端到端路径上继续发送更多的新的分组。
P43.

流量控制将无法适用，因为接受缓存足够大。
没有丢包、没有超时，因此拥塞控制也无法适用。
无需适用任何措施，当发送缓存满载时，自动就慢下来了。
P44.

a.
每个 RTT 加 1 个 MSS，因此需要 6 个 RTT

b.
6 + 7 + 8 + 9 + 10 + 11 = 51 MSS
平均吞吐量为 51MSS / 6RTT = 8.5 MSS/RTT
P45.

a.
从 W/2RTT 到 W/RTT 期间总共发送的分组数：
W2+(W2+1)+(W2+2)+...+W=(W+W2)(W−W2+1)2=38W2+34W

2W​+(2W​+1)+(2W​+2)+...+W=2(W+2W​)(W−2W​+1)​=83​W2+43​W

仅丢了一个包，因此丢包率L=138W2+34W

仅丢了一个包，因此丢包率L=83​W2+43​W1​

b.
当W足够大，38W2>>34W，此时L≈138W2=8/3W2

当W足够大，83​W2>>43​W，此时L≈83​W21​=8/3W2

得出W≈8/3L−−−−√
得出W≈8/3L

​

则平均吞吐率为=0.75WRTT≈1.22MSSRTTL√
则平均吞吐率为=RTT0.75W​≈RTTL

​1.22MSS​
P46.

a.
最大窗口长度 W 受限于链路速率：W * MSS / RTT = 10Mbps
得到 W = 125

b.
从 W/2 到 W：
平均窗口长度为 0.75W = 94
平均吞吐量为 94 * 1500 * 8 / 0.15 = 7.52Mbps

c.
W’ = W/2 + 3 = 65
从 W’ 到 W：
(125-65)*150ms = 9s
P47.

不会
P48.

a.
W*MSS/RTT = 10Gbps
W = 125000

b.
7.52Gbps

c.
156.2min
P49.

已知 TCP 平均吞吐量 D=1.22MSSRTTL√
D=RTTL

​1.22MSS​

L=(1.22MSSRTT∗D)2

L=(RTT∗D1.22MSS​)2

1L为丢包后(的那一刻)TCP发送的总分组数(因为只丢了一个包)

L1​为丢包后(的那一刻)TCP发送的总分组数(因为只丢了一个包)

则MSSL=T∗D,T=D∗RTT21.222MSS

LMSS​=T∗D,T=1.222MSSD∗RTT2​

因此 T 是 D 的函数
P50.

每秒发送最多 30 个报文段，即每 100ms 最多发送 3 个，每 50ms 最多发送 1 个；无论何时发生丢包，假定 C1 每 100ms 调整一次窗口， C2 每 50ms 调整一次。
a.
t/ms 	C1.cwnd/报文段 	C2.cwnd/报文段
0 	10 	10
50 	5↓ （↓ 的意思是因丢包而减少一半） 	10
100 	2↓ 	5↓
150 	1↓ 	5
200 	1▲ （▲ 的意思是无法继续减少） 	2↓
250 	1▲ 	2
300 	1▲ 	1↓
350 	2↑（↑ 的意思是加性增） 	1
400 	1↓ 	1▲
450 	2↑ 	1
500 	1↓ 	1▲
550 	2↑ 	1
600 	1↓ 	1▲
650 	2↑ 	1
700 	1↓ 	1▲
750 	2↑ 	1
800 	1↓ 	1▲
850 	2↑ 	1
900 	1↓ 	1▲
950 	2↑ 	1
1000 	1↓ 	1▲

因此它们的拥塞窗口为 1、1

b.
C1 明显比 C2 占有的带宽多一些，是 C2 的三倍
P51.

类似上一题
a.
都是2
t/ms 	C1.cwnd/报文段 	C2.cwnd/报文段
0 	15 	10
100 	7↓ 	5↓
200 	3↓ 	2↓
300 	1↓ 	1↓
400 	2↑ 	2↑
500 	1↓ 	1↓
600 	2↑ 	2↑
700 	1↓ 	1↓
800 	2↑ 	2↑
900 	1↓ 	1↓
1000 	2↑ 	2↑
1100 	1↓ 	1↓
1200 	2↑ 	2↑
1300 	1↓ 	1↓
1400 	2↑ 	2↑
1500 	1↓ 	1↓
1600 	2↑ 	2↑
1700 	1↓ 	1↓
1800 	2↑ 	2↑
1900 	1↓ 	1↓
2000 	2↑ 	2↑
2100 	1↓ 	1↓
2200 	2↑ 	2↑

b.
是的

c.
是的，都是2

d.
不利于改善利用率
当 C1 C2 的窗口大小都为 1 时，这条链路无法满载。
可以增设一个缓冲区，在缓冲区溢出之前随机丢弃一些分组。主动队列管理，随机早期检测等都用到了此种方法。
P52.

1.
类似 P45：

S=W2+W2(1+a)+W2(1+a)2+...+W

S=2W​+2W​(1+a)+2W​(1+a)2+...+W

设 W2(1+a)n=W

2W​(1+a)n=W ：

得 n=log1+a2

n=log1+a​2

从而 S=W(2a+1)2a

S=2aW(2a+1)​

则丢包率 L=1S=2aW(2a+1)

L=S1​=W(2a+1)2a​

2.
从 W/2 增加到 W 需要的时间：

n∗RTT=log1+a2∗RTT

n∗RTT=log1+a​2∗RTT

跟吞吐量无关
P53.

根据公式：

D=1.22MSSRTTL√
D=RTTL

​1.22MSS​

L=(1.22MSSRTT∗D)2=(1.22∗1500byte0.1s∗10Gbps)2=(14640109)2=2∗10−10

L=(RTT∗D1.22MSS​)2=(0.1s∗10Gbps1.22∗1500byte​)2=(10914640​)2=2∗10−10

而当 D’ = 100Gbps 时：

L=(146401010)2=2∗10−12

L=(101014640​)2=2∗10−12
P54.

优点是无需经历慢启动过程
缺点是 t1 时刻的 cwnd 和 ssthresh 比较陈旧，不能正确反映 t2 时刻的线路拥塞状态
P55.

a.
Y

b.
可以确认，SYNACK 将发到 Y，攻击者无法得知初始的序号，也就无法发回正确的 ACK
P56.

略

# 第四章

复习题
R1.

网络层分组叫做数据报。路由器处于第三层的，链路交换机是第二层
R2.

数据报网络中两个最重要的功能是：转发和路由，虚电路网络中增加了一项：连接建立
R3.

转发是指在路由器内部将输入端口的分组转移到正确的输出端口；而路由是指路由器决定从源到目的地的路径
R4.

是的
R5.

略
R6.

IP电话等
R7.

有了影子副本，就可以在每个输入端口本地进行转发决策，而无需基于每个数据包调用集中式路由处理器，从而避免集中处理瓶颈。
R8.

分别是内存交换，总线交换和纵横结构。只有纵横结构可以并行转发。
R9.

如果分组到达的速率大于交换结构的速率，那么就会造成排队，最终队列越来越长，导致分组丢失。解决方法就是提升交换结构的速率至 n 倍的输入线路速率，n 是端口数
R10.

假设输入速率和输出速率一致，当分组到达单个输出端口的速率大于线路速率时，就会造成排队，最终队列越来越长，导致分组丢失。增加交换结构的速率对减缓排队现象没有任何帮助。
R11.

HOL：head-of-the-line
HOL阻塞的意思是，队列最前端的分组由于某种原因被阻塞，它后面的分组即使可以被转发结构转发，也需要等到最前端被转发之后才可以被转发。
它出现在输入端口。
R12.

路由器有 IP 地址，每一个接口都有一个 IP
R13.

11011111.00000001.00000011.00011011
R14.

略
R15.

8、3
R16.

20+20/20+20+40 = 50%
50% 的开销
R17.

IP 头部中“协议”字段，可以用来判断是 TCP 或 UDP 或其他。
R18.

无线路由器内置 DHCP 服务器，使用 DHCP 分发 IP 地址等。当然了，路由器也使用 NAT，因为只有一个公网 IP 要分配个五台 PC。
R19.

略
R20.

同意，因为 IPv6 的数据报被封装在 IPv4 的数据报中
R21.

链路状态路由协议是层次式的，网络中的路由器并不向邻居传递“路由项”，而是通告给邻居一些链路状态。与距离矢量路由协议相比，链路状态协议对路由的计算方法有本质的差别。距离矢量协议是平面式的，所有的路由学习完全依靠邻居，交换的是路由项。链路状态协议只是通告给邻居一些链路状态。运行该路由协议的路由器不是简单地从相邻的路由器学习路由，而是把路由器分成区域，收集区域的所有的路由器的链路状态信息，根据状态信息生成网络拓扑结构，每一个路由器再根据拓扑结构计算出路由。
R22.

路由器被组织成 AS，在一个 AS 中，所有路由器运行相同的AS内部协议，在跨越 AS 时需要使用AS间协议。
R23.

没有必要
R24.

不会改变，因为初始表中通过 B 到 z 跳数是 7，然而来自 A 的通告到 z 需要 11 跳，因此表不会改变。
R25.

RIP 路由选择更新信息在邻居间通过使用一种 RIP 响应报文来交换，大约 30 秒交换一次。
而 OSPF 向 AS 内部所有其他路由广播路由选择信息，不仅仅是邻居，每当一条链路的状态发生变化时，路由器就会广播链路状态信息，即使未发生变化，它也周期性地广播链路状态。
R26.

路径上的 AS 序列
R27.

请看课本 P268
R28.

略
R29.

子网是较大型网络的一部分，不包含路由器，其边界定义为路由器和主机的接口。
前缀是 CDIR 地址的网络部分。
带有 属性 的 前缀 叫做一条 BGP 路由。
R30.

路由器使用 AS-PATH 来检测和防止循环通告，也使用它在多条路径中选择相同前缀。
NEXT-HOP 指示沿给定前缀的通告路径（位于接收通告的 AS 之外）的第一路由器的IP地址。
R31.

举个例子，ISP B 不想传输从 ISP A 和 C 之间的流量，它就可以不向 A 和 C 通告这条路由路径。
R32.

使用单播模拟广播，效率低，它可能会在同一条链路上多次发送相同的数据包；而且寻址困难，源必须知道所有接收方的地址
R33.

a. 无控制洪泛和受控洪泛都可能接收到同一个分组的多个副本
b. 无控制洪泛可能通过相同的出链路转发多个分组的副本
R34.

不需要
R35.

IGMP 为主机提供了一种方式，让它通知第一跳路由器，本机上的一个应用程序想要加入一个特定的多播组。 IGMP 协议只运行在主机和它的第一跳多播路由器之间。然后由多播路由器与其他多播路由器协同工作，即运行多播路由选择协议，以确保加入主机的多播组的数据被路由到适当的最后一跳路由器，并从那里路由到主机。
R36.

组共享的树：所有的发送方都在同一条路由树上发送多播流量
基于源的树：每个源都有自己的一颗多播路由选择树
习题
P1.

a.
数据报体系更好，使用虚电路当出现无法工作的路由器时，需要重新建立连接。而数据报体系更加“灵活”，路由表可以通过距离向量算法或链路状态算法更新。

b.
虚电路体系更好，虚电路是面向连接的，路由器维持连接状态信息，可以为源到目的的会话提供固定容量。

c.
数据报将有更多的流量控制开销，这是由数据报中各种数据包报头造成的
P2.

a. 2^8 = 256
b. 中文版翻译看不懂什么意思，较为清晰的翻译应该是：在连接建立时由某个中央结点决定路径和 VC 号。按照题意，中央结点只需在 [0, 2^8-1] 之间选择一个未被使用的即可。这种虚电路中的 VC 号不可能比(a)中确定的少
c. 每条链路都能独立分配 VC 号，路由器将这些对应的 VC 号写入转发表，当特定 VC 号的分组到达后，将其 VC 号替换为对应的 VC 号并转发
P3.

入接口、入VC号、出接口、出VC号
目的地址范围、输入接口
P4.

a.
目的地址 	输出接口
H3 的 IP 	3

b.
转发只能基于目的地址，因此无法实现。实际上英文版上是“trick question”。

c.
A 	入接口 	入VC号 	出接口 	出VC号
	1 	16 	3 	27
	2 	3 	4 	58

d.
B 	入接口 	入VC号 	出接口 	出VC号
	1 	27 	2 	52
C 	入接口 	入VC号 	出接口 	出VC号
	1 	58 	3 	22
D 	入接口 	入VC号 	出接口 	出VC号
	1 	52 	3 	19
	2 	22 	3 	30
P5.
P6.

connection-oriented service & connection service

在虚电路中，每个路径上的路由器都维持连接状态信息。
而在面向连接的运输层服务中，由端系统维持连接状态信息。运输层服务通过无连接的网络层传输，例如 TCP 通过 IP 传输，中间路由器并不知道自己在维持连接。
P7.

a. 不能
b. 可能
c. 不能
P8.

书上有误，应该是“n个分组到达n个输入端口”，把“出”改成“入”。

(n-1)D、(n-1)D、0
D 为输入（输出）时延，内存、总线的时延是一致的，有 n 个分组在排队，即使是发往不同的输出端口。
P9.

中文版的字母看不清，从上到下、从左到右依次是 X X Y Z Y

需要三个时隙，例如时隙 1 发送最上面的 X 和中间的 Y，时隙 2 发送中间的 X 和下面的 Y，时隙 3 发送下面的 Z。
最坏也需要三个时隙，时隙 1 发送上面的 X 和中间或下面的 Y，时隙 2 也能发送两个，时隙 3 发送最后剩余的 1 个。
P10.

a.
难点在接口 2 的写法
前缀匹配 	链路接口
11100000 00 	0
11100000 01000000 	1
1110000 	2
11100001 1 	3
其他 	3

b.
第一个为其他，选择了接口 3；第二个选择 2；第三个选了 3
P11.

接口 0：从 00000000 到 00111111，共 2^6=64
接口 1：从 01000000 到 01011111，共 2^5=32
接口 2：从 01100000 到 01111111，从 10000000 到 10111111，共 2^5 + 2^6 = 96
接口 3：从 11000000 到 11111111，共 2^6 = 64
P12.

与上题类似，略
P13.

子网 1：223.1.17.192/26
子网 2：223.1.17.0/25
子网 3：223.1.17.128/28
可以多种不同分配方案
P14.

与下题类似，略
P15.
目的地址 	接口
224.0/10 	0
224.64/16 	1
224/7 	2
225.128/9 	3
其他 	3
P16.

地址范围为 128.119.40.128~128.119.40.191，任意给出一个即可

2^6=64 64/4=16 即每个子网有16个IP

子网 1：128.119.40.64/28
子网 2：128.119.40.80/28
子网 3：128.119.40.96/28
子网 4：128.119.40.112/28
P17.

略
P18.

whois 不能用来确定某个特定 IP 地址的确定位置。但是可以使用 www.maxmind.com。
P19.

⌈2400−20700−20⌉=4

⌈700−202400−20​⌉=4
因此需要 4 个分片。每个 IP 数据报都有相同的标识号 422；4个数据报的偏移分别是 0、85、170、255；等等。
P20.

与上题类似，略
P21.

a.
可以随意分配
主机 192.168.1.1 192.168.1.2 192.168.1.3，路由器接口地址 192.168.1.4

b.
NAT 转换表：
WAN端 	LAN端
24.34.112.235 5001 	192.168.1.1 3345
24.34.112.235 5002 	192.168.1.1 3346
24.34.112.235 5003 	192.168.1.2 3345
24.34.112.235 5004 	192.168.1.2 3346
24.34.112.235 5005 	192.168.1.3 3345
24.34.112.235 5006 	192.168.1.3 3346
P22.

a.
既然我们可以捕获所有分组，那么只需统计 IP 分组的标识号即可

b.
不能正常工作
P23.

Arwold 和 Bernard 都位于 NAT 之后，任一方都不能与对方建立连接
P24.

略
P25.

略
P26.
步骤 	N’ 	y 花费、路径 	z 花费、路径 	v 花费、路径 	w 花费、路径 	u 花费、路径 	t 花费、路径
0 	x 	6，xy 	8，xz 	3，xv 	6，xw 	∞ 	∞
1 	xv 	6，xy 	8，xz 		6，xw 	6，xvu 	7，xvt
2 	xvy 		8，xz 		6，xw 	6，xvu 	7，xvt
3 	xvyw 		8，xz 			6，xvu 	7，xvt
4 	xvywu 		8，xz 				7，xvt
5 	xvywut 		8，xz 				
6 	xvywutz 						
P27.

略
P28.
从…到…的费用 	u 	v 	x 	y 	z
v 	∞ 	∞ 	∞ 	∞ 	∞
x 	∞ 	∞ 	∞ 	∞ 	∞
z 	∞ 	6 	2 	∞ 	∞

第一次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	∞ 	6
x 	∞ 	3 	0 	3 	2
z 	7 	5 	2 	5 	0

第二次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	3 	5
x 	4 	3 	0 	3 	2
z 	6 	5 	2 	5 	0

第三次迭代：
从…到…的费用 	u 	v 	x 	y 	z
v 	1 	0 	3 	3 	5
x 	4 	3 	0 	3 	2
z 	6 	5 	2 	5 	0
P29.

算法收敛于 最长的无环路的距离减一 次迭代
P30.

略
P31.

略
P32.

减少费用不会出现无穷计数，因为不会造成路由选择环路。
连接两个结点相当于将无穷的费用减少为链路的费用。
P33.

每一次结点距离向量的更新都是基于 Bellman-Ford 公式，只会不断减少它们的距离向量。如果距离向量不再减少，即不再更新，在有限步内它们就会稳定下来。
P34.

a题翻译有误，应为 w、y、z 向彼此告知它们到 x 的距离。
a.
z 	到 x 的距离
告诉 w 	∞
告诉 y 	6
y 	到 x 的距离
告诉 w 	4
告诉 z 	4
w 	到 x 的距离
告诉 y 	∞
告诉 z 	5

b.
存在无穷计数问题。
y 计算它到 x 的距离 Dy(x) = min{ c(y,x)+Dx(x), c(y,z)+Dz(x)} = min{60, 6+3} = 9
然而这个值是错误的，将导致一个路由选择环路。

c.
将 y 和 z 切断
P35.

通过 AS-PATH
P36.

课本上有介绍，首先选择的是本地偏好值中的路由，然后才是最短 AS 路径
P37.

a. eBGP
b. iBGP
c. eBGP
d. iBGP
P38.

a. I1，因为 I1 离 1c 近
b. I2，虽然跨越的 AS 的数量相同，但是 I2 离 NEXT-HOP 路由器更近
c. I1，因为经 I1 的话 AS-PATH 更小
P39.

略
P40.

x 的视图：
x的视图
y 的视图：
y的视图
P41.

比如 BitTorrent 或其他 P2P 应用
P42.

A 向 B 通告两个路由：AS-PATH 为 A-W 和 A-V
A 向 C 通告一个路由： A-V
C 收到的 AS-PATH 为：B-A-W，B-A-V，A-V
P43.

Z 想传送来自 Y 的流量，因此 Z 向 Y 发送路由通告，但是 Z 无法阻止 Y 向 X 通告此路径，最终 X 也将向 Z 传送流量
P44.

可以用 Kruskal 或 Prim 算法 计算最小生成树
P45.

如果路由器二叉树是一个满二叉树：
向一个接收方发送一个分组的费用是 5，因此单播模拟的总费用是 5*32=160
网络层广播将报文复制并发送其副本，因此费用为 2+4+8+16+32 = 62

当拓扑的形状是一条直线时，所有接收方都连在距离发送方最远的结点上，费用相差最大
P46.

p46
可能有多种画法。
设加粗的路径是 A 的最小生成树。 这时 B 将收到来自 A、C、D 的广播报文。
P47.

略
P48.

略
P49.

p49
P50.

略
P51.

例如：
1
对于 Dijkstra（源为A）:
2
对于最小生成树：
3
P52.

3*2^(t-1)
P53.

协议必须建立在应用层才行，举例来说，应用程序可以在应用层报文中周期性地向其他组成员多播它的身份。
P54.

一个最简单的应用层协议设计，就是所有成员都向所有其他成员多播自己得身份，在带内发送报文即可。
P55.

D类地址得第一个字节以“1110”开始，因此可用位为32-4=28，空间为 N=2^28
两个不同组选择相同地址的概率=1/N=2^-28
1000个组不冲突的概率=N(N-1)(N-2)…(N-999)/N^1000
冲突概率=1-N(N-1)(N-2)…(N-999)/N^1000

# 第五章

复习题
R1.

火车飞机汽车等等
R2.

尽管链路可以提供可靠交付服务，但无法保证 ip 数据报是按序交付的，而 TCP 仍然需要一个正确的字节顺序。
而且路由器产生丢包时，将没有补救措施。
R3.

书上 291 页：
成帧：IP 和 TCP 也提供成帧
链路接入：IP 和 TCP 都不提供
可靠交付：TCP 提供可靠传输
差错检测和纠正：IP 和 TCP 都会检测
R4.

会，传播时延比 L/R 小，没等传完呢，就检测到对方也在传输了
R5.

时序Aloha：1、2、4
时序Aloha需要所有结点同步，因此不满足第三点

令牌环网：1、2、3、4
R6.

从 {0,1,2…31} 选 4，概率是 1/32
4 * 5.12ms = 204.8ms
R7.

略
R8.

传递令牌需要很长时间
R9.

2^48 2^32 2^128
R10.

C 会直接丢弃。但如果是广播，C会传给网络层
R11.

因为无法知道 IP 所对应的 MAC 地址。接收方知道发送方的 IP 及 MAC，没有必要再广播了
R12.

不可能
R13.

略
R14.

2
被路由器分成了两个子网，一个内网一个外网
R15.

12 比特的标识符，因此是 2^12 个
R16.
习题
P1.

1 1 1 0 | 1
0 1 1 0 | 0
1 0 0 1 | 0
1 1 0 1 | 1
————
1 1 0 0 | 0
P2.

例如，P1中的分组出现单比特差错：
1 0 1 0 | 1
0 1 1 0 | 0
1 0 0 1 | 0
1 1 0 1 | 1
————
1 1 0 0 | 0

可以定位是第一行第二列出错

如果是双比特差错：
1 1 1 0 | 1
0 1 1 0 | 0
1 0 0 1 | 0
1 1 0 1 | 1
————
1 1 0 0 | 0

可以检测出错误，但是无法纠正
P3.

  01001110 01100101
+ 01110100 01110111
 ——————————————————
  11000010 11011100
+ 01101111 01110010
 ——————————————————
1)00110010 01001110
  00110010 01001111
+ 01101000 01101001
 ——————————————————
  10011010 10111000
+ 01101110 01100111
 ——————————————————
1)00001001 00011111
  00001001 00100000

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15

如果溢出就加到最后一位上
反码为 11110110 11011111
P4.

略
P5.

R=0100
P6.

略
P7.

a.
设第 i 位反转，0<=i<=d+r-1，则接收到的数据 K = D*2^r XOR R + 2^i，如果用 G 除 K，那么余数一定不为 0

b.
对此题而言，一个关键点是：G 能被 11（二进制）整除，但任意奇数比特差错都不能整除11，因此也不能整除 G，所以可以检测出奇数比特差错。
P8.

a.
f( p ) = Np(1-p)^(N-1)
f’( p ) = N(1-p)^(N-1) - Np(N-1)(1-p)^(N-2) = N(1-p)^(N-2)(1-Np)
令 f’( p ) = 0：得 p’ = 1/N

b.
将 p’ = 1/N 代入：
Np’(1-p’)^(N-1) = (1-1/N)^(N-1) = (1-1/N)^N * (1-1/N)^(-1) = 1/e
P9.

g( p ) = N p(1-p)^(2(N-1))
g’( p ) = N (1-p)^(2(N-1)) - 2(N-1)Np (1-p)^(2(N-1)-1)
= N (1-p)^(2(N-1)-1) ((1-p)-2(N-1)p)

解出：p’ = 1/(2N-1)

则 g(p’) = N/(2N-1) * (1-1/(2N-1))^(2(N-1)) = N/(2N-1) * (1-1/(2N-1))^(2N-1) * (1-1/(2N-1))^(-1) = (1-1/(2N-1))^(2N-1) * N/(2N-2)
当 N 趋于无穷：g(p’) = 1/2e
P10.

a.
A 的平均吞吐量 = PA(1-PB)
总体效率 = PA(1-PB) + PB(1-PA)

b.
A 的平均吞吐量 = PA(1-PB) = 2PB - 2PB^2
B 的平均吞吐量 = PB(1-PA) = PB - 2PB^2
2PB - 2PB^2 ≠ 2(PB - 2PB^)

要使 PA(1-PB) = 2PB(1-PA)：PA = 2PB/(1+PB)

c.
A：2p(1-p)^(N-1)
其他：p(1-p)^(N-2)(1-2p)
P11.

略
P12.

略
P13.

一个轮询周期为 N(Q/R + dpoll)，一个周期传输总比特 NQ，因此吞吐量为 NQ/N(Q/R + dpoll) = Q/(Q/R + dpoll)
P14.

a.
p14
b. 如图所示
c. 略 d. 略
P15.

S1 是 子网 1 和 子网 2 之间的交换机

a.
不会，E 检查 F 的 IP 的子网前缀，就会知道它们在同一个局域网中，因此不会发给 R1，就是 E 和 F 的 IP 和 MAC。

b.
不会，因为它们不在同一局域网。

源 IP： E 的 IP
目的 IP： B 的 IP
源 MAC： E 的 MAC
目的 MAC：R1 右侧的接口 MAC

c.
交换机 S1 收到 ARP 之后将其继续广播，并且它知道 A 在子网 1 中，因此会更新转发表，添加主机 A。
是的，R1 会收到这个 ARP 请求，但 R1 不会转发子网 3。
B 不会发送 ARP 请求 A 的 MAC，因为可以从 A 的 ARP 请求中获得。
S1 收到之后会将此帧丢弃，因为 A、B 在同一局域网。
P16.

S2 是 子网 2 和 子网 3 之间的交换机

a.
不会，同上题。

b.
会，因为 E 想要知道 B 的 MAC 地址。

源 IP： E 的 IP
目的 IP： B 的 IP
源 MAC： E 的 MAC
目的 MAC：B 的 MAC 地址

c.
交换机 S1 收到 ARP 之后将其继续广播，并且它知道 A 在子网 1 中，因此会更新转发表，添加主机 A。
是的，S2 收到之后也会向其所有接口转发。
B 不会发送 ARP 请求 A 的 MAC，因为可以从 A 的 ARP 请求中获得。
S1 收到之后会将此帧丢弃，因为 A、B 在同一局域网。
P17.

10Mbps：100*512bit/10Mbps = 5.12ms
100Mbps：0.512ms
P18.

设 A 传送 512+64=576 比特：
t=0，A 开始传送；t=325，第一个比特到达 B；在最坏情况下，B 在 t=324 开始传送自己的帧；当 t=324+325=649 时，此帧到 A，而 649>576，A 已传输完，因此 A 错误地认为自己成功传输。
P19.

课本上没讲人为干扰信号 jamming signal，在谢老师的书上有这么一个概念，就是强化碰撞，当发送数据的站检测到了碰撞，除了立即停止发送数据外，还要继续发送 32 比特或 48 比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。
还有帧间最小间隔的概念，以太网规定帧间最小间隔为 9.6 μs，即 96 比特时间
比特时间 	事件
0 	A B 开始发送数据
245 	A B 检测到碰撞并停止发送数据
245+48=293 	A B 停止发送 48 比特的人为干扰信号
293+245=538 	B 的最后一个字节到达 A；A 检测到空闲信道
538+96=634 	A 开始传输
293+512=805 	B 等待 512 比特时间
634+245=879 	A 的传输到达 B

B 开始重传的时间为 805+96=901 > 879，因此不会再碰撞。
P20.

略
P21.

假定仍按照 P14(a) 中规定的 IP 与 MAC 来做：
在整个过程中，源 IP、目的 IP 都不会改变，只有 MAC 会改变：
(i)源：00-00-00-00-00-00 目的：11-11-11-11-11-11
(ii)源：33-33-33-33-33-33 目的：66-66-66-66-66-66
(iii)源：77-77-77-77-77-77 目的：99-99-99-99-99-99
P22.

中文版有误，不是“左边路由器”，是“交换机”
在整个过程中，源 IP、目的 IP 都不会改变，只有 MAC 会改变：
(i)源：00-00-00-00-00-00 目的：66-66-66-66-66-66
(ii)源：00-00-00-00-00-00 目的：66-66-66-66-66-66
(iii)源：77-77-77-77-77-77 目的：99-99-99-99-99-99
P23.

所有 11 个节点都以 100Mbps 发送数据，则总的聚合吞吐量为 1100Mbps
P24.

500Mbps
P25.

100Mbps
P26.

(i) B 向 E 发送一个帧，交换机记录 B 的 MAC 地址与到达的端口；由于不知道 E 对应的接口，它向 A、C、D、E、F 都发送此帧
(ii) E 向 B 回答一个帧：交换机记录 B 的 MAC 地址与到达的端口；已知 B 的接口，只向 B 转发
(iii) A 向 B 发送一个帧：交换机记录 A 的 MAC 地址与到达的端口；已知 B 的接口，只向 B 转发
(iv) B 向 A 回答一个帧：交换机保持表的内容不变；已知 A 的接口，只向 A 转发
P27.

a.
L*8bit/128kbps = L/16 ms

b.
L=1500：分组化时延=1500/16=93.75ms
L=50：分组化时延=50/16=3.125ms

c.
L=1500：存储转发时延=(L+5)*8bit/622Mbps=19.4μs
L=50：存储转发时延=(L+5)*8bit/622Mbps=0.707μs

d.
使用小分组长度，分组化时延会比较小
P28.

为 EE 的三台主机分配 111.111.1.1，111.111.1.2，111.111.1.3，子网掩码 111.111.1/24；
为 CS 的三台主机分配 111.111.2.1，111.111.2.2，111.111.2.3，子网掩码 111.111.2/24；
路由器连接交换机端口 1 的接口卡可被配置成包含两个子接口 IP 地址：111.111.1.0 和 111.111.2.0，第一个子接口地址是连接 EE 的子网，第二个是连接 CS 的子网
每一个 IP 地址可与一个 VLAN ID 关联。假设 111.111.1.0 与 VLAN 11 关联，111.111.2.0 与 VLAN 12 关联。这意味着从子网 111.111.1/24 来的帧会被加上一个 802.1q 的标签 VLAN ID 11；从子网 111.111.2/24 来的帧会被加上一个 802.1q 的标签 VLAN ID 12；

当 EE 中的主机 A(111.111.1.1) 想要给 CS 中的主机 B(11.111.2.1) 发一个 IP 数据报。主机 A 首先将目的地址为 111.111.2.1 的 IP 数据报放进一个帧里，MAC 地址是连接交换机端口 1 的接口卡地址。路由器接收到这个帧之后，决定一个将其发给 IP 地址为 111.111.2.0 的子接口。当封装此 IP 数据报时，应当在帧上附加一个 802.1q 标签 VLAN ID 12。当这个帧被端口 1 收到之后，交换机发现了 ID 为 12，它会将这个帧发送到主机 B，主机 B 收到之后会将 802.1q 标签移除。
P29.

略
P30.

略
P31.

课本中有
P32.
P33.

# 第六章

## 复习题6 

## 问题6 

# 第七章

## 复习题7 



## 问题7 




# 参考文档：

[1]第一章 https://blog.csdn.net/one_of_a_kind/article/details/82502936
[2]第二章 https://blog.csdn.net/one_of_a_kind/article/details/82824938
[3]第三章 https://blog.csdn.net/one_of_a_kind/article/details/82933106
[4]第四章 https://blog.csdn.net/one_of_a_kind/article/details/83050360
[5]第五章 https://blog.csdn.net/one_of_a_kind/article/details/83118052

[Back to Index](#目录)