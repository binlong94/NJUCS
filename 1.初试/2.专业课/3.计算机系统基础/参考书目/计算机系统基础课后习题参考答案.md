# 目录

## [说明](#说明)

# 说明

## 版本信息

书名：《计算机系统基础（第二版）》 袁春风

整理日期：2019-10-27 

整理人：李加其（幽弥狂）

内容：课后习题参考答案 

联系方式：13812991101

邮箱：1768478912@qq.com

QQ:1768478912

版本：v1.0

## 声明

1、如果有侵权或者其他问题欢迎联系我。

2、参考书目为https://github.com/JackeyLea/NJUCS中README.md文件中列出的参考书目。

3、红色字体为重要内容，比如曾作为课后习题、考试考过等等。

4、括号里的P**表示在书本的第几页。

# 第一部分 系统概述和可执行目标文件的生成

## 第一章计算机系统概述

1、见《计算机系统基础习题解答与教学指导》

2、简单回答下列问题。

（1）冯·诺依曼计算机由哪几部分组成？各部分的功能是什么？

    控制器：用于控制主动执行指令；

    运算器：用于执行指令；

    存储器：存放数据和指令；

    输入输出设备：通过输入输出设备使用计算机；

（2）什么是“存储程序”工作方式？

    必须将事先编好的程序和原始数据送人主存后才开能执行程序，一旦程序被启动执行，计算机能在必须操作人员干预的情况下自动完成逐条指令取出和执行任务。（P3）

（3）一条指令的执行过程包含哪几个阶段？

    程序的执行就是指令的执行过程。

	阶段：
	取指令、取数、传数、ALU运算阶段。（P6）

（4）计算机系统的层次结构如何划分？

	电路设计、数字设计、ISA、汇编程序、编译程序、应用程序、操作系统（P18 图1.11）

（5）计算机系统的用户可分哪几类？每类用户工作在哪个层次？

   	用户有四种：

	最终用户：应用程序级

	系统管理员：操作系统

	应用程序员：编译程序

	系统程序员：汇编程序和ISA之间

（6）程序的 CPI 与哪些因素有关？

	总时钟周期数、指令条数（P20）

（7）为什么说性能指标 MIPS 不能很好地反映计算机的性能？

	MIPS反映了机器执行定点指令的速度。首先，不同机器的指令集是不同的，而且指令的功能也是不同的，也许在机器1上一条指令完成的功能机器2需要多条指令。其次，不同机器的CPI和时钟周期也是不同的，因此同一条指令在不同的机器上所用的时间也不同。（P20 最后一段）

3、略

4、略

5、题目略

仿照图1.3

| 主存地址 | 主存单元地址 | 内容说明（Ii表示第i条指令） | 指令的符号表示 |
| --- | --- | --- | --- |
| 0 | 1110 0111 | I1：R[0]←M[7]；op=1110；取数操作 | load r0,7# |
| 1 | 0000 0100 | I2：R[1]←R[0]；op=0000；传送操作 | mov r1,r0 |
| 2 | 1110 0101 | I3：R[0]←M[6]；op=1110；取数操作 | load r0,6# |
| 3 | 0010 0001 | I4：R[0]←R[0]-R[1]；op=0010；减操作 | sub r0,r1 |
| 4 | 0011 0001 | I5：R[0]←R[0]*R[1]；op=0011；乘操作 | mul r0,r1 |
| 5 | 1111 1000 | I6：M[8]←R[0]；op=1111；存数操作 | store 8#,r0 |
| 6 | 0001 0000 | 操作数x，值为16 |   |   |
| 7 | 0010 0001 | 操作数y，值为33 |   |   |
| 8 | 0000 0000 | 结果z，初始值为0 |   |   |

仿照图1.5 

|操作| I1:1110 0111 | I2：0000 0100 | I3：1110 0101 | I4：0010 0001 | I5：0011 0001 | I6：1111 1000 |
|---|---|---|---|---|---|---|
|取指令|IR←M[0000]|IR←M[0001]|IR←M[0010]|IR←M[0011]|IR←M[0100]|IR←M[0101]|
|指令译码|op=1110，取数|op=0000，传送|op=1110，取数|op=0010，减|op=0011，乘|op=1111，存数|
|PC增量|PC←0000+1|PC←0001+1|PC←0010+1|PC←0011+1|PC←0100+1|PC←0101+1|
|取数并执行|MDR←M[0110]|A←R[0]、mov|MDR←M[0101]|A←R[0]、B←R[1]、sub|A←R[0]、B←R[1]、mul|MDR←R[0]|
|送结果|R[0]←MDR|R[1]←F|R[0]←MDR|R[0]←F|R[0]←F|M[1000]←MDR|
|执行结果|R[0]=33|R[1]=33|R[0]=16|R[0]=16-33=-17|R[0]=-17×33|M[8]=-561|

6、若有两个基准测试程序P1和P2在机器M1和M2上运行，假定M1和M2的价格分别是5000元和8000元，下表给出了P1和P2在M1和M2上所花的时间和指令条数。

<table>
    <tr>
        <th rowspan="2">程序</th>
        <th colspan="2">M1</th>
		<th colspan="2">M2</th>
    </tr>
    <tr>
        <td>指令条数</td>
        <td>执行时间(ms)</td>
		<td>指令条数</td>
        <td>执行时间(ms)</td>
    </tr>
    <tr>
        <td>P1</td>
        <td>200×10^6</td>
        <td>10000</td>
		<td>150×10^6</td>
		<td>5000</td>
    </tr>
    <tr>
        <td>P2</td>
        <td>300×10^3</td>
        <td>3</td>
		<td>420×10^3</td>
		<td>6</td>
    </tr>
</table>

请回答下列问题：

（1）对于P1，哪台机器的速度快？快多少？对于P2呢？

    对于P1，M2比M1快一倍；对于P2，M1比M2快一倍。

（2）在M1上执行P1和P2的速度分别是多少MIPS？在M2上的执行速度又各是多少？从执行速度来看，对于P2，哪台机器的速度快？快多少？

	对于M1，P1的速度为：200M/10=20MIPS；P2为300k/0.003=100MIPS。

	对于M2，P1的速度为：150M/5=30MIPS；P2为420k/0.006=70MIPS。

	从执行速度来看，对于P2，因为100/70=1.43倍，所以M1比M2快0.43倍。


（3）假定M1和M2的时钟频率各是800MHz和1.2GHz，则在M1和M2上执行P1时的平均时钟周期数CPI各是多少？ 

	在M1上执行P1时的平均时钟周期数CPI为：10×800M/(200×106)=40。

	在M2上执行P1时的平均时钟周期数CPI为：5×1.2G/(150×106)=40。

（4）如果某个用户需要大量使用程序P1，并且该用户主要关心系统的响应时间而不是吞吐率，那么，该用户需要大批购进机器时，应该选择M1还是M2？为什么？（提示：从性价比上考虑）

	考虑运行P1时M1和M2的性价比，因为该用户主要关心系统的响应时间，所以性价比中的性能应考虑执行时间，其性能为执行时间的倒数。故性价比R为：

	R=1/(执行时间×价格)

	R越大说明性价比越高，也即，“执行时间×价格”的值越小，则性价比越高。

	因为10×5000 > 5×8000，所以，M2的性价比高。应选择M2。

（5）如果另一个用户也需要购进大批机器，但该用户使用P1和P2一样多，主要关心的也是响应时间，那么，应该选择M1还是M2？为什么？

	P1和P2需要同等考虑，性能有多种方式：执行时间总和、算术平均、几何平均。

	若用算术平均方式，则：因为 (10+0.003)/2×5000 > (5+0.006)/2×8000，所以M2的性价比高，应选择M2。

	若用几何平均方式，则：因为sqrt(10×0.003) ×5000 < sqrt(5×0.006) ×8000，所以M1的性价比高，应选择M1。

7．若机器M1和M2具有相同的指令集，其时钟频率分别为1GHz和1.5GHz。在指令集中有五种不同类型的指令A~E。下表给出了在M1和M2上每类指令的平均时钟周期数CPI。

|机器 | A | B | C | D | E |
|----|---|---|---|---|---|
|M1 | 1 | 2 | 2 | 3 | 4 |
|M2 | 2 | 2 | 4 | 5 | 6 |

请回答下列问题：
（1）M1和M2的峰值MIPS各是多少？

	M1上可以选择一段都是A类指令组成的程序，其峰值MIPS为1000MIPS。
	M2上可以选择一段A和B类指令组成的程序，其峰值MIPS为1500/2=750MIPS。

（2）假定某程序P的指令序列中，五类指令具有完全相同的指令条数，则程序P在M1和M2上运行时，哪台机器更快？快多少？在M1和M2上执行程序P时的平均时钟周期数CPI各是多少？

	5类指令具有完全相同的指令条数，所以各占20%。
	在M1和M2上执行程序P时的平均时钟周期数CPI分别为：
    	M1：20%×(1+2+2+3+4)= 0.2×12 = 2.4
		M2：20%×(2+2+4+5+6)= 0.2×19 = 3.8
	假设程序P的指令条数为N，则在M1和M2上的执行时间分别为：
		M1：2.4× N×1/1G = 2.4N (ns)
		M2：3.8×N×1/1.5G = 2.53 N (ns)
	M1执行P的速度更快，每条指令平均快0.13ns，也即M1比M2快0.13/2.53×100%≈5%。

8．假设同一套指令集用不同的方法设计了两种机器M1和M2。机器M1的时钟周期为0.8ns，机器M2的时钟周期为1.2ns。某个程序P在机器M1上运行时的CPI为4，在M2上的CPI为2。对于程序P来说，哪台机器的执行速度更快？快多少？

	假设程序P的指令条数为N，则在M1和M2上的执行时间分别为：
		M1：4 N×0.8 = 3.2N (ns)
		M2：2 N×1.2 = 2.4 N (ns)  
	所以，M2执行P的速度更快，每条指令平均快0.8ns，比M1快0.8/3.2×100%=25%。

9．假设某机器M的时钟频率为4GHz，用户程序P在M上的指令条数为8×109，其CPI为1.25，则P在M上的执行时间是多少？若在机器M上从程序P开始启动到执行结束所需的时间是4秒，则P占用的CPU时间的百分比是多少？

	程序P在M上的执行时间为：1.25×8××1/4G = 2.5 s，
	从启动P执行开始到执行结束的总时间为4秒，
	其中2.5秒是P在CPU上真正的执行时间，
	其他时间可能执行操作系统程序或其他用户程序。
	程序P占用的CPU时间的百分比为：2.5/4 = 62.5%。

10．假定某编译器对某段高级语言程序编译生成两种不同的指令序列S1和S2，在时钟频率为500MHz的机器M上运行，目标指令序列中用到的指令类型有A、B、C和D四类。四类指令在M上的CPI和两个指令序列所用的各类指令条数如下表所示。
| | A	| B	| C	| D |
|--| ---|---|---|---|
各指令的CPI	1	2	3	4
S1的指令条数	5	2	2	1
S2的指令条数	1	1	1	5

请问：S1和S2各有多少条指令？CPI各为多少？所含的时钟周期数各为多少？执行时间各为多少？

	S1有10条指令，CPI为 (5×1+2×2+2×3+1×4)/10=1.9, 所含的时钟周期数为10×1.9=19，执行时间为19/500M = 38ns。
	S2有8条指令，CPI为 (1×1+1×2+1×3+5×4)/8 =3.25, 所含的时钟周期数为8×3.25=26，执行时间为26/500M = 52ns。 

10．假定机器M的时钟频率为1.2GHz，某程序P在机器M上的执行时间为12秒钟。对P优化时，将其所有的乘4指令都换成了一条左移2位的指令，得到优化后的程序P’。已知在M上乘法指令的CPI为5，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中有多少条乘法指令被替换成了左移指令被执行？
参考答案：
显然，P’的执行时间为10秒，因此，P比P’多花了2秒钟，因此，执行时被换成左移指令的乘法指令的条数为1.2G×2/(5–2) = 800M。


## 第二章计算机系统基本功能和基本组成

1、见习题解答。

2、简单回答下列问题。

（1）为什么计算机内部采用二进制表示信息？既然计算机内部所有信息都用二进制表示，为什么还要用到十六进制或八进制数？

制造两个稳定状态的元器件比多个稳定状态的元器件要容易，两个稳定状态对应高低电平，正好可以用0/1表示；二进制编码规则简单，可用开关电路实现；方便通过逻辑电路实现算术运算。
二进制硬件容易理解，但是不方便书写和阅读。

（2）常用的定点数编码方式有哪几种？ 通常它们各自用来表示什么？

原码：用定点原码表示浮点数的尾数部分；

补码：带符号整数；

反码：

移码：

（3）为什么计算机中大多用补码表示带符号整数？

（4）在浮点数的基和位数一定的情况下，浮点数的表数范围和表数精度分别由什么决定？两者如何相互制约？

（5）为什么要对浮点数进行规格化？有哪两种规格化操作？

（6）为什么有些计算机中除了用二进制外还用 BCD 码来表示数值数据？

（7）为什么计算机处理汉字时会涉及到不同的编码（如，输入码、内码、字模码）？说明这些编码中哪些是用二进制编码，哪些不是用二进制编码，为什么？

3．实现下列各数的转换。
（1）(25.8125)10= (?)2= (?) 8= (?) 16

（2）(101101.011)2 = (?)10= (?) 8= (?) 16= (?) 8421

（3）(0101 1001 0110.0011)8421 = (?)10= (?) 2= (?) 16

（4）(4E.C)16 = (?)10= (?) 2

参考答案：

（1）	(25.8125)10 = (1 1001.1101)2 = (31.64) 8 = (19.D) 16

（2）(101101.011)2 = (45.375)10 = (55.3) 8 = (2D.6) 16 = (0100 0101.0011 0111 0101) 8421

（3）(0101 1001 0110.0011)8421 = (596.3)10 = (1001010100.01001100110011…) 2 = (254.4CCC…) 16

（4）(4E.C)16 = (78.75)10 = (0100 1110.11) 2

4． 假定机器数为8位（1位符号，7位数值），写出下列各二进制数的原码和补码表示。
+0.1001，–0.1001，+1.0，–1.0，+0.010100，–0.010100，+0，–0

参考答案：
| 原码 | 补码 |
|----- |-----|
|+0.1001：			0.1001000			0.1001000
–0.1001：			1.1001000			1.0111000
+1.0：				溢出				溢出
–1.0：				溢出				1.0000000
+0.010100：		    0.0101000			0.0101000
–0.010100：			1.0101000			1.1011000
+0：				0.0000000			0.0000000
–0：				1.0000000			0.0000000

5． 假定机器数为8位（1位符号，7位数值），写出下列各二进制数的补码和移码表示。
+1001，–1001，+1，–1，+10100，–10100，+0，–0
参考答案：     		    
移码				  补码
+1001：			    10001001		    00001001
–1001：				01110111			    11110111
+1：				10000001			00000001
–1：				011111111			11111111
+10100：			10010100			00010100
–10100：			01101100				11101100
+0：				10000000			00000000
–0：				10000000			00000000

6． 已知 [x]补，求x
（1）[x]补=1.1100111           （2）[x]补=10000000
（3）[x]补=0.1010010          （4）[x]补=11010011
参考答案：
（1）[x]补=1.1100111           x = –0.0011001B
（2）[x]补=10000000 			 x = –10000000B = –128
（3）[x]补=0.1010010			 x = +0.101001B
（4）[x]补=11010011			 x = – 101101B = – 45

7．假定一台32位字长的机器中带符号整数用补码表示，浮点数用IEEE 754标准表示，寄存器R1和R2的内容分别为R1：0000108BH，R2：8080108BH。不同指令对寄存器进行不同的操作，因而，不同指令执行时寄存器内容对应的真值不同。假定执行下列运算指令时，操作数为寄存器R1和R2的内容，则R1和R2中操作数的真值分别为多少？
（1）无符号数加法指令
（2）带符号整数乘法指令
（3）单精度浮点数减法指令
参考答案：
	R1 	= 0000108BH = 0000 0000 0000 0000 0001 0000 1000 1011b
	R2	= 8080108BH = 1000 0000 1000 0000 0001 0000 1000 1011b
（1）对于无符号数加法指令，R1和R2中是操作数的无符号数表示，因此，其真值分别为R1：108BH, R2：8080108BH。
（2）对于带符号整数乘法指令，R1和R2中是操作数的带符号整数补码表示，由最高位可知， R1为正数， R2为负数。R1的真值为+108BH, R2的真值为–(0111 1111 0111 1111 1110 1111 0111  0100b + 1b) = –7F7FEF75H。
（3）对于单精度浮点数减法指令，R1和R2中是操作数的IEEE754单精度浮点数表示。在IEEE 754 标准中，单精度浮点数的位数为32位，其中包含1位符号位，8位阶码，23位尾数。
由R1中的内容可知，其符号位为0，表示其为正数，阶码为0000 0000，尾数部分为000 0000 0001 0000 1000 1011，故其为非规格化浮点数，指数为–126，尾数中没有隐藏的1，用十六进制表示尾数为+0.002116H，故R1表示的真值为+0.002116H × 10-126。
由R2中的内容可知，其符号位为1，表示其为负数，阶码为0000 0001， 尾数部分为000 0000 0001 0000 1000 1011，故其为规格化浮点数，指数为1–127 = –126，尾数中有隐藏的1，用十六进制表示尾数为–1.002116H，故R2表示的真值为–1.002116H × 10-126

8．假定机器M的字长为32位，用补码表示带符号整数。下表第一列给出了在机器M上执行的C语言程序中的关系表达式，请参照已有的表栏内容完成表中后三栏内容的填写。
关系表达式	运算类型	结果	说明
0 == 0U
–1 < 0
–1 < 0U
2147483647 > –2147483647 – 1
2147483647U > –2147483647 – 1
2147483647 > (int) 2147483648U
–1 > –2
(unsigned) –1 > –2	无符号整数
有符号整数
无符号整数
有符号整数
无符号整数
有符号整数
有符号整数
无符号整数	1
1
0
1
0 
1
1
1	00…0B = 00…0B
11…1B (–1) < 00…0B (0)
11…1B (232–1) > 00…0B(0)
011…1B (231–1) > 100…0B (–231)
011…1B (231–1) < 100…0B(231)
011…1B (231–1) > 100…0B (–231)
11…1B (–1) > 11…10B (–2)
11…1B (232–1) > 11…10B (232–2)

9．以下是一个C语言程序，用来计算一个数组a中每个元素的和。当参数len为0时，返回值应该是0，但是在机器上执行时，却发生了存储器访问异常。请问这是什么原因造成的，并说明程序应该如何修改。
   	1	float sum_elements(float a[], unsigned len)
	2	{
	3		int 	i;
	4		float  result = 0;
	5
	6		for	(i = 0; i <= len–1; i++)
	7			result += a[i];
	8		return result;
	9	}

参考答案：
参数len的类型是unsigned，所以，当len=0时，执行len-1的结果为11…1，是最大可表示的无符号数，因而，任何无符号数都比它小，使得循环体被不断执行，引起数组元素的访问越界，发生存储器访问异常。
	只要将len声明为int型，或循环的测试条件改为i<len。

1.  设某浮点数格式为：



其中，移码的偏置常数为16，补码采用一位符号位，基数为4。
（1）用这种格式表示下列十进制数：+1.7，–0.12，+19，–1/8。
（2）写出该格式浮点数的表示范围，并与12位定点补码整数表示范围比较。
参考答案：（假定采用0舍1入法进行舍入）
（1） +1.7 = +1.1011001B = 0.011011B× 41, 故阶码为1 +16 = 17 = 10001B, 尾数为+0.011011的补码， 即0.011011，所以+1.7表示为0 10001 011011。

	–0.12 = – 0.000111101B = – 0.011111B × 4–1, 故阶码为 –1 + 16 =15 = 01111B, 尾数为– 0.011111的补码，即1.100001, 所以–0.12表示为1 01111 100001。

	+19 = +10011B = 0.010011B× 43，故阶码为3 + 16 = 19 = 10011B, 尾数为0.010011，所以+19表示为0 10011 010011。

	–1/8 = – 0.125 = – 0.001B = – 0.100000 × 4–1，阶码为 –1 + 16 = 15 = 01111B，尾数为– 0.100000的补码，即1.100000，所以–1/8表示为1 01111 100000。

（2）该格式浮点数表示的范围如下。
	正数最大值：0.111111B × 411111，即：0.333× 415  （≈230 ≈109）
	正数最小值：0.000001B × 400000，即：0.001× 4–16  （≈2–34≈10–10）
	负数最大值：–0.000001B × 400000，即：–0.001× 4–16
	负数最小值：–1.000000B × 411111，即：–1.000× 415
    因此，该格式浮点数的数量级在10–10～109之间。
12位定点补码整数的表示范围为：–211～+(211–1)，即：–2048～2047
由此可见，定点数和浮点数的表示范围相差非常大。

11. 下列几种情况所能表示的数的范围是什么？
（1）16位无符号整数
（2）16位原码定点小数
（3）16位补码定点小数
（4）16位补码定点整数
（5）下述格式的浮点数（基数为2，移码的偏置常数为128）



	参考答案：
（1）无符号整数：0～216–1。
（2）原码定点小数：–(1–2–15) ～ + (1–2–15)。
（3）补码定点小数：–1 ～ + (1–2–15)。
（4）补码定点整数：–32768 ～ +32767。
（5）浮点数：负数：– (1–2–7)×2+127 ～ –2–7×2–128。
正数：+2–135 ～ (1–2–7) ×2+127。

12. 以IEEE 754单精度浮点数格式表示下列十进制数。
+1.75，+19，–1/8，258
参考答案：
	+1.75 = +1.11B = 1.11B × 20, 故阶码为0+127=01111111B, 数符为0，尾数为1.110…0，小数点前为隐藏位，所以+1.7表示为0 01111111 110 0000 0000 0000 0000 0000，用十六进制表示为3FE00000H。

	+19 = +10011B = +1.0011B × 24，故阶码为4+127 = 10000011B, 数符为0，尾数为1.00110…0，所以+19表示为0 10000011 001 1000 0000 0000 0000 0000，用十六进制表示为41980000H。

	–1/8 = – 0.125 = – 0.001B = – 1.0 × 2–3，阶码为–3+127 = 01111100B，数符为1，尾数为1.0…0，所以–1/8表示为1 01111100 000 0000 0000 0000 0000 0000，用十六进制表示为BE000000H。

258=100000010B=1.0000001B × 28, 故阶码为8+127=10000111B, 数符为0，尾数为1.0000001，所以258表示为0 10000111 000 0001 0000 0000 0000 0000，用十六进制表示为43810000H。

13．设一个变量的值为4098，要求分别用32位补码整数和IEEE 754单精度浮点格式表示该变量（结果用十六进制表示），并说明哪段二进制序列在两种表示中完全相同，为什么会相同？
参考答案：
4098 = +1 0000 0000 0010B = +1. 0000 0000 001 × 212
    32位2-补码形式为：0000 0000 0000 0000 0001 0000 0000 0010 （00001002H）
	IEEE754单精度格式为：0 10001011 0000 0000 0010 0000 0000 000 （45801000H）
    粗体部分为除隐藏位外的有效数字，因此，在两种表示中是相同的序列。

14．设一个变量的值为–2147483647，要求分别用32位补码整数和IEEE754单精度浮点格式表示该变量（结果用十六进制表示），并说明哪种表示其值完全精确，哪种表示的是近似值。
参考答案：
–2147483647 = –111 1111 1111 1111 1111 1111 1111 1111B
= –1.11 1111 1111 1111 1111 1111 1111 1111 × 230
    32位2-补码形式为：1000 0000 0000 0000 0000 0000 0000 0001 （80000001H）
	IEEE 754单精度格式为：1 10011101 1111 1111 1111 1111 1111 111 （CEFFFFFFH）
    32位2-补码形式能表示精确的值，而浮点数表示的是近似值，低位被截断

15．下表给出了有关IEEE 754浮点格式表示中一些重要数据的取值，表中已经有最大规格化数的相应内容，要求填入其他浮点数的相应内容。（注：表中a代表一个在1到10之间的正纯小数）
项目	阶码	尾数	单精度	双精度
			以2的幂次表示的值	以10的幂次表示的值	以2的幂次表示的值	以10的幂次表示的值
0
1
最大规格化数
最小规格化数
最大非规格化数
最小非规格化数
+∞
NaN	00000000
01111111
11111110
00000001
00000000
00000000
11111111
11111111	0….00
0….00
1…11
0….00
1…11
0…01
0….00
非全0	0
1
(2–2–23)×2127
1.0×2–126
(1–2–23)×2–126
2–23×2–126=2–149
–
–	0
1
a×1038
a×10–38
a×10–38
a×10–44
–
–	0
1
(2–2–52)×21023
1.0×2–1022
(1–2–52)×2–1022
2–52×2–1022
–
–	0
1
a×10308
a×10–308
a×10–308
a×10–?
–
–


16．已知下列字符编码：A=100 0001，a=110 0001，0=011 0000，求E、e、f、7、G、Z、5的7位ACSII码和第一位前加入奇校验位后的8位编码。
参考答案：
	E的ASCII码为 ‘A’ + (‘E’ – ‘A’) = 100 0001 + 100 = 100 0101, 奇校验位P = 0，第一位前加入奇校验位后的8位编码是0 100 0101。
	e的ASCII码为‘a’+ (‘e’ – ‘a’) = 110 0001 + 100 = 110 0101， 奇校验位P = 1, 第一位前加入奇校验位后的8位编码是1 110 0101。
	f的ASCII码为‘a’+ (‘f’ – ‘a’) = 110 0001 + 101 = 110 0110, 奇校验位P = 1, 第一位前	加入奇校验位后的8位编码是 1 110 0110。
	7的ASCII码为‘0’+ (7 - 0)  = 011 0000 + 111 = 011 0111,奇校验位P = 0, 第一位前加入奇校验位后的8位编码是0 011 0111。
	G的ASCII码为‘A’+ (‘G’ – ‘A’) = 100 0001 + 0110 = 100 0111, 奇校验位P = 1, 第一位前加入奇校验位后的8位编码是1 100 0111。
	Z的ASCII码为‘A’+(‘Z’ – ‘A’) = 100 0001 + 11001 = 101 1010, 奇校验位P = 1, 第一位前加入奇校验位后的8位编码是 1 101 1010。
	5的ASCII码为‘0’+(5 – 0) = 011 0000 + 101 = 011 0101， 奇校验位P = 1, 第一位前加入奇校验位后的8位编码是 1 011 0101。

17．假定在一个程序中定义了变量x、y和i，其中，x和y是float型变量（用IEEE754单精度浮点数表示），i是16位short型变量（用补码表示）。程序执行到某一时刻，x = –0.125、y=7.5、i=100，它们都被写到了主存（按字节编址），其地址分别是100，108和112。请分别画出在大端机器和小端机器上变量x、y和i在内存的存放位置。
参考答案：
–0.125 = –0.001B = –1.0 × 2-3
x在机器内部的机器数为：1 01111100 00…0 (BE00 0000H)
7.5= +111.1B= +1.111 × 22
y在机器内部的机器数为：0 10000001 11100…0 (40F0 0000H)
100=64+32+4=1100100B
i在机器内部表示的机器数为：0000 0000 0110 0100（0064H）
大端机						  小端机
地址	内容						 	内容	
100		BEH							00H
			101		00H								00H
			102		00H								00H
			103		00H								BEH
			108		40H								00H
			109		F0H							    00H
			110		00H								F0H
			111		00H								40H
			112		00H								64H
			113		64H								00H

18．假定某计算机的总线采用奇校验，每8位数据有一位校验位，若在32位数据线上传输的信息是8F 3C AB 96H，则对应的4个校验位应为什么？若接受方收到的数据信息和校验位分别为87 3C AB 96H和0101B，则说明发生了什么情况，并给出验证过程。
    参考答案：
    传输信息8F 3C AB 96H展开为1000 1111 0011 1100 1010 1011 1001 0110，每8位有一个奇校验位，因此，总线上发送方送出的4个校验位应该分别为0、1、0、1。
    接受方的数据信息为87 3C AB 96H，展开后为1000 0111 0011 1100 1010 1011 1001 0110；接收到的校验位分别为0、1、0、1。在接受方进行校验判断如下：
    根据接收到的数据信息计算出4个奇校验位分别为1、1、0、1，将该4位校验位分别和接收到的4位校验位进行异或，得到1、0、0、0，说明数据信息的第一个字节发生传输错误。对照传输前、后的数据信息，第一字节8FH变成了87H，说明确实发生了传输错误，验证正确。
    

19．写出16位数据的SEC码。假定数据为0101 0001 0100 0110，说明SEC码如何正确检测数据位5的错误。
	参考答案：
对于16位数据， 可以如下插入校验位：
	M16 M15 M14 M13 M12 P5 M11 M10 M9 M8 M7 M6 M5 P4 M4 M3 M2 P3 M1 P2 P1
	其中Mi是原信息数据， Pi是加入的校验位， 对于各个校验位的值可以如下计算
	P1 = M1⊕M2⊕M3⊕M4⊕M5⊕M7⊕M9⊕M11⊕M12⊕M14⊕M16 = 1
	P2 = M1⊕M3⊕M4⊕M6⊕M7⊕M10⊕M11⊕M13⊕M14 = 1
	P3 = M2⊕M3⊕M4⊕M8⊕M9⊕M10⊕M11⊕M15⊕M16 = 0
	P4 = M5⊕M6⊕M7⊕M8⊕M9⊕M10⊕M11 = 0
	P5 = M12⊕M13⊕M14⊕M15⊕M16 = 0
	所以此时P5 P4 P3 P2 P1 = 00011，第五位数据出错时，数据字变为：0101 0001 0101 0110，P5’P4’P3’P2’P1’= 01010，故障字 =  00011⊕01010 = 01001，说明码字第9位出错，即M5出错。

20．假设要传送的数据信息为：100011，若约定的生成多项式为：G(x)= x3+1，则校验码为多少？假定在接收端接收到的数据信息为100010，说明如何正确检测其错误，写出检测过程。

参考答案：
原数据信息为100011，对应的报文多项式为M(x) = x5 + x + 1, 生成多项式的位数为4位， 所以在原数据信息后面添加3个0，变为M’(x) = x3M(x) = x8 + x4 + x3, 用M(x)去模2除G(x)，得到的余数为111， 所以得到CRC码为100011 111。

	检测时， 用接收到的CRC码去模2除生成多项式1001，若得到的余数为0，则表明正确，否则说明传输时发生了错误。此题中接收到的CRC码为100010 111（即数据100010加检验位111），显然，用100010 111 模2除 1001，得到余数为001，不为0，说明传输时发生错误。


# 更新说明

2019-10-27：新建文档，从试题文档中复制模板